# 1、数组

## （1）二分法

### 1、区间开闭问题

定义 target 是在⼀个在左闭右闭的区间⾥，**也就是****[left, right]****

![image-20240520220220356](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240520220220356.png)

定义 target 是在⼀个在左闭右开的区间⾥，也就是[left, right) 

![image-20240520220324074](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240520220324074.png)

### 2、双指针法

双指针法有两种类型，一种是两个指针在同一侧开始

```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int i=0;
        for(int j=0;j<nums.size();j++){
            if(val!=nums[j]){
                nums[i++]=nums[j];
            }
        }
        return i;
    }
};
```

一种是两个指针在数组的两侧开始

```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        vector<int> result(nums.size(), 0);
        int k=result.size()-1;
        while (left <= right) {
            if (nums[left] * nums[left] <= nums[right] * nums[right]) {
                result[k--] = nums[right] * nums[right];
                right--;
            } else {
                result[k--] = nums[left] * nums[left];
                left++;
            }
        }
        return result;
    }
};
```

### [34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

解法1：暴力求解

```
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> two_elements = {-1, -1};
        
        for(int i=0;i<nums.size();i++){
            if(nums[i]==target){
                if(two_elements[0]==-1){
                    two_elements[0]=i;
                }
                     two_elements[1]=i;
                
              
            }
        }
        return two_elements;
    }
};
```

解法2:二分法

```
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        vector<int> two_elements = {-1, -1};
        while(left<=right){
            int middle=(left+right)/2;
            if(target<nums[middle]){
                right=middle-1;

            }else if(nums[middle]<target){
                left=middle+1;
            }else{
              
             two_elements[0] = middle;
                // 检查左侧是否有更多目标值
                left = middle - 1;
                while (left >= 0 && nums[left] == target) {
                    left--;
                }
                two_elements[0] = left + 1;
                
                // 检查右侧是否有更多目标值
                right = middle + 1;
                while (right < nums.size() && nums[right] == target) {
                    right++;
                }
                two_elements[1] = right - 1;
                break;
            }
        }
        return two_elements;
    }
};
```

### [26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

双指针法：

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int j=0;
        for(int i=1;i<nums.size();i++){
            if(nums[i]!=nums[j]){
                j++;
                nums[j]=nums[i];
                
            }
        }
        return j+1;
    }
};
```

STL函数

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());
        return nums.size();
    }
};
```

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

### [283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/)

双指针

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int j=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]!=0){
                nums[j++]=nums[i];
            }
        }
        while(j<nums.size()){
            nums[j++]=0;
            
        }
    }
};
```

### [844. 比较含退格的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/backspace-string-compare/)

不会

使用栈来实现

```
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        return build(S) == build(T);
    }

    string build(string str) {
        string ret;
        for (char ch : str) {
            if (ch != '#') {
                ret.push_back(ch);
            } else if (!ret.empty()) {
                ret.pop_back();
            }
        }
        return ret;
    }
};

```



### [977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

stl函数

```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int i=0,j=0;
        
       
        for(int i=0;i<nums.size();i++){
            nums[j++]=(nums[i]*nums[i]);
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```

本题可练习多种排序

### [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

# 2、链表

都使用虚拟头节点

### [203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/submissions/534386793/)

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //使用虚拟头节点
        ListNode *dummyHead=new ListNode(0);
        dummyHead->next=head;
        ListNode *cur=dummyHead;

        while(cur->next!=NULL){
            if(cur->next->val==val){
                ListNode *tmp=cur->next;
                cur->next=cur->next->next;
                delete tmp;
            }else{
                cur=cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```

### [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)

链表经典题，涉及链表操作（统一使用虚拟头节点）

定义一个临时指针来遍历，

- 获取第n个节点的值（n从0开始）
- 头部插入节点
- 尾部插入节点
- 第n个节点前插入节点
- 删除第n个节点

### [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

反转链表

```
// 使用栈来反转链表的函数
ListNode* reverseList(ListNode* head) {
    if (head == nullptr) return nullptr; // 空链表直接返回

    std::stack<ListNode*> stack; // 创建一个栈

    // 遍历链表，将所有节点压入栈中
    ListNode* current = head;
    while (current != nullptr) {
        stack.push(current);
        current = current->next;
    }

    // 弹出栈顶元素，作为反转后链表的头节点
    ListNode* newHead = stack.top();
    stack.pop();
    current = newHead;

    // 继续弹出栈中元素，并依次连接成新的链表
    while (!stack.empty()) {
        current->next = stack.top();
        stack.pop();
        current = current->next;
    }
    current->next = nullptr; // 最后一个元素的next指针设置为nullptr

    return newHead; // 返回反转后的链表头节点
}
```

### [24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)

记录临时节点

### [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummyHead=new ListNode(0);
        dummyHead->next=head;
        ListNode *slow=dummyHead;
        ListNode *fast=dummyHead;
        while(n--&&fast!=NULL)
        {
            fast=fast->next;
        }
        fast=fast->next;
        while(fast!=NULL)
        {
            fast=fast->next;
            slow=slow->next;
        }


        ListNode*temp=slow->next;
        slow->next=slow->next->next;
        delete temp;
        temp=nullptr;
        return dummyHead->next;
    }
};
```

# 3、哈希表

### [383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/description/)

```
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
      
        int record[26]={0};
        for(int i=0;i<ransomNote.size();i++)
        {
            record[ransomNote[i]-'a']++;
        }
        for(int i=0;i<magazine.size();i++)
        {
            record[magazine[i]-'a']--;
        }
        for(int i=0;i<26;i++)
        {
            if(record[i]>0)
            {
                return false;
            }
        }
        return true;
    }
};

```

### [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)（细节题）

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++){
            if(nums[i]>0){
                return result;
            }
            if (i > 0 && nums[i] == nums[i - 1]) 
            {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left)
            {
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else
                {
                    /* 把三个数放到二维数组，然后对b和c进行去重*/
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    while (right > left && nums[right] == nums[right - 1])
                    {
                        right--;
                    } 
                    while (right > left && nums[left] == nums[left + 1]) 
                    {
                        left++;
                    }
                    right--;
                    left++;
                }
            }
        }
         return result;
    }
};
```

### [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)

和三数之和类似

```

```



### [454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/)

```
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> umap;
        for(int a:nums1)
        {
            for(int b:nums2){
                //插入
                umap[a+b]++;
            }
            
        }
        int count=0;
        for(int c:nums3)
        {
            for(int d:nums4)
            {
                if (umap.find(0 - (c + d)) != umap.end())
                {
                    count += umap[0 - (c + d)];
                }
            }
        }
        return count;
    }
};
```

