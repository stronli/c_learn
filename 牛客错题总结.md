## 1、递归

递归指的是在函数的定义中调用自身的方法

```
#include <stdio.h>
 
double factorial(unsigned int i)
{
   if(i <= 1)
   {
      return 1;
   }
   return i * factorial(i - 1);
}
int  main()
{
    int i = 15;
    printf("%d 的阶乘为 %f\n", i, factorial(i));
    return 0;
}
```



## 2、经典排序算法

### （1）冒泡排序

冒泡排序就是每次都重复地走访过要排序的数列，一次比较两个元素

冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。

![img](https://www.runoob.com/wp-content/uploads/2018/09/Bubble_sort_animation.gif)

```
#include<stdio.h>
void bubble_sort(int arr[],int len){
	int i,j,temp;
	for(i=0;i<len-1;i++){
		for(j=0;j<len-1-i;j++){
		if(arr[j]>arr[j+1]){
			temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
		}
		}
	}
}
int main() {
    int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    bubble_sort(arr, len);
    int i;
    for (i = 0; i < len; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

### （2）选择排序

遍历所有的元素，然后找到最小或者最大的部分



选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

![img](https://www.runoob.com/wp-content/uploads/2018/09/Selection_sort_animation.gif)

```
void selection_sort(int a[], int len) 
{
    int i,j,temp;
 
    for (i = 0 ; i < len - 1 ; i++) 
    {
        int min = i;                  // 记录最小值，第一个元素默认最小
        for (j = i + 1; j < len; j++)     // 访问未排序的元素
        {
            if (a[j] < a[min])    // 找到目前最小值
            {
                min = j;    // 记录最小值
            }
        }
        if(min != i)
        {
            temp=a[min];  // 交换两个变量
            a[min]=a[i];
            a[i]=temp;
        }
        /* swap(&a[min], &a[i]);  */   // 使用自定义函数交換
    }
}
 
/*
void swap(int *a,int *b) // 交换两个变量
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
*/
```

### （3）插入排序



插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

```
void insertion_sort(int arr[], int len){
    int i,j,temp;
    for (i=1;i<len;i++){
            temp = arr[i];
            for (j=i;j>0 && arr[j-1]>temp;j--)
                    arr[j] = arr[j-1];
            arr[j] = temp;
    }
}
```



## 3、C/C++错题总结

### 1、字符串错题

```
以下字符串定义与赋值中，正确的是（）
A
char s[80] = {"A", "B", "C"}
B
char s[80]; s = {'A', 'B', 'C'}
C
char s[80]; s = "ABC";
D
char s[80] = "ABC";
```

- A：char s[80] = {"A", "B" ,"C"}

  后面是对数组元素进行初始化，而每个元素是字符所有应该用单引号。 

- B:char s[80]; s = {'A', 'B','C'}

  这个的错误是由于对数组初始化必须在定义的时候，否则不能对数组进行像上面这样的整体赋值，只能对单个元素进行赋值。

-  char s[80]; s = "ABC";

  这个的错误原因和B类似。

字符串定义一般为

```
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
char site[] = "RUNOOB";
```

### 2、sizeof和strlen

`sizeof` 和 `strlen` 是 C/C++ 中用于处理字符串的两个重要函数，它们有着不同的功能和用法。

- `sizeof` 是一个运算符，用于返回其操作数的字节大小。在对字符数组使用 `sizeof` 时，返回的是整个数组的大小，包括结尾的空字符（'\0'）。
- `strlen` 是一个函数，用于计算以空字符（'\0'）结尾的字符串的长度，不包括空字符在内。

举个例子：

```
char str[] = "Hello";
size_t size = sizeof(str); // size 的值是 6，因为 "Hello" 包含 5 个字符和一个结尾的空字符
size_t length = strlen(str); // length 的值是 5，因为 "Hello" 有 5 个字符
```

需要注意的是，`sizeof` 返回的是字节数，而 `strlen` 返回的是字符串中的字符数（不包括结尾的空字符）。

3、

```
#include <iostream>
using namespace std;
void fun(int *p1, int *p2, int *t)
{
    t = (int *)malloc(sizeof(int));
    *t = *p1 + *(p2++);
}
int main()
{
    int a[2] = { 1,2 };
    int b[2] = { 10,20 };
    int *t = a;
    fun(a, b, t);
    cout << *t << endl;
}
输出结果为1
```

## 4、双指针法