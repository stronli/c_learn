# 网络编程

网络编程（套接字编程）

**IP地址**

- IP地址是网络中主机(电脑)的标识
- 在网络中主机想要与其他机器通信就必须拥有一个自己的IP地址
- IP地址为32位（IPV4）或者128位（IPV6）
- 每一个数据包都必须携带目的地址IP和源IP地址，路由器依靠此信息为数据包选择最优路由（路线）

**端口号 （用于区分计算机中某一个具体的程序）**

- 用于区分一台主机中接收到的数据包应该转交给哪一个进程进行处理。
- TCP端口号与UDP端口号是相互独立的
- 端口号一般由IANA(Internet Assigned Numbers Authority) 统一管理
- 众所周知端口： 1 - 1023 （1-25之间为众所周知端口 ， 256 - 1023 为UNIX系统占用）
- 何为总所周知端口其实就是早已固定号的端口比如80端口分配给WWW服务，21端口分配给FTP服务等
- 注册端口： 1024 -49151 分配给进程或者应用。这些端口号在还没有被服务器资源占用时，可以由用户的APP动态注册获得。

## 1、Socket大致介绍

Socket（套接字）是计算机网络中用于通信的一种机制，它允许不同的计算机在网络上进行通信。Socket 是在应用层和传输层之间的一个抽象层，提供了一组接口和函数，使得应用程序可以通过网络发送和接收数据。

## 2、Socket 主要分为两种类型：流式套接字（SOCK_STREAM）和数据报套接字（SOCK_DGRAM）。

- **流式套接字**：使用面向连接的 TCP 协议，提供可靠的、双向的、基于字节流的数据传输。
- **数据报套接字**：使用无连接的 UDP 协议，提供不可靠的、单向的、基于数据报的数据传输。
- ![img](https://img-blog.csdnimg.cn/d8defba857774042bd8ab171b0eebf2f.png)

## 3、socket编程是在tcp/ip上的网络编程

![img](https://img-blog.csdnimg.cn/a092cf9a9a4f4b0ea1513caea5ba1838.png)

## 4、tcp的三次握手和四次挥手

### 1、三次握手

在tcp/ip协议中，tcp通过三次握手建立起一个tcp的链接，大致如下：

- syn包：用于建立连接，syn=1为希望建立连接
- ACK：确认应答号是否有效，1为有效
- seq：序列号，发送数据的位置
- ack：确认应答号，下次发送数据位置

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzk3NDkwLWY4NjY4OGNmNDkxZjJlOTMucG5n?x-oss-process=image/format,png)

1. 第一次握手：客户端尝试连接服务器，向服务器发送syn包，seq=x，客户端进入SYN_SEND状态等待服务器确认。

   其实就是，客户端给服务器发消息，说我想和你连接（syn包），序列号（seq）是存放syn包的位置，这是第一次握手，这时客户端就会进入SYN_SEND状态等待服务器确认。

2. 第二次握手：服务器接收客户端syn包并确认（ack=x+1），同时向客户端发送一个SYN包（syn=1），即SYN+ACK包，此时服务器进入SYN_RECV状态。

   就是服务器收到客户端的信息，然后确认连接，回复客户端syn=1，说我可以和你连接，同时确认连接时间，就是ack，为x+1.此时服务器进入SYN_RECV状态。这次发送在服务器标记为y

3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=x+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

   客户端收到syn=1和ack为x+1，然后就发送说客户端这次从x+1发送,服务器你就从y+1开始发送，此包发送完毕，客户端和服务器进入ESTABLISHED（确认已连接状态）状态，完成三次握手。

   

### 2、四次挥手

TCP 四次挥手断开连接。TCP连接是双向的，在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzk3NDkwLWU1MWMxNDU1MTM5NzNlOGYucG5n?x-oss-process=image/format,png)

数据传输完毕后，双方都可以释放连接.
此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开连接，服务器被动断开连接.

1, 客户端进程发出连接释放报文，并且停止发送数据。
释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2, 服务器收到连接释放报文，发出确认报文，ACK=1，确认序号为 u+1，并且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（关闭等待）状态。

TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3, 客户端收到服务器的确认请求后，此时客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最终数据）

4, 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5, 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，确认序号为w+1，而自己的序列号是u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6, 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/sinat_36629696/article/details/80740678

## 5、Socket 编程通常涉及以下步骤：

| ![img](https://img-blog.csdnimg.cn/a8572d32678041d2a068010966805505.png) | ![img](https://img-blog.csdnimg.cn/bb7a44e26b6e42c4a1a5e1f547668310.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |



1. 创建 Socket：应用程序调用 `socket` 函数创建一个套接字，并指定通信域（如 IPv4、IPv6）、套接字类型（如 TCP、UDP）和协议类型。1

   ```
     int socket(int domain, int type, int protocol);
   3 参数：
   4 domain：域。
   5 AF_INET/PF_INET： 网际协议
   6 AF_UNIX/PF_UNIX：本地协议，可写成 AF_LOCAL/PF_LOCAL
   7 type：类型。
   8 SOCK_STREAM：流式套接字 TCP协议
   9 SOCK_DGRAM：数据报套接字 UDP协议
   10 protocol：协议。
   11 一般为 0
   12 返回值：
   13 成功：待连接套接字
   14 失败：-1
   ```

   绑定 Socket：如果是服务器程序，通常需要将套接字绑定到一个具体的 IP 地址和端口上，以便接受来自客户端的连接。

   ```
     int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
   2 参数：
   3 sockfd：待连接套接字
   4 addr：包含本地地址（IP+PORT）的通用地址结构体的指针
   5 addrlen：地址结构体大小
   6 返回值：
   7 成功：0
   8 失败：-1
   
    struct sockaddr // 通用IP信息结构体
   2 {
   3 sa_family_t sa_family;
   4 char sa_data[14];
   5 }
   6
   7 struct sockaddr_in // IPV4地址结构体
   8 {
   9 u_short sin_family;// 地址族
   10 u_short sin_port;// 端口
   11 struct in_addr sin_addr;// IPV4 地址
   12 char sin_zero[8];
   13 };
   14
   15 struct in_addr // IP地址结构体
   16 {
   17 in_addr_t s_addr;// 无符号 32 位网络地址
   18 };
   ```

   监听连接请求（仅针对流式套接字）：对于 TCP 套接字，服务器通常需要调用 `listen` 函数开始监听来自客户端的连接请求。

   ```
   1 int listen(int sockfd, int backlog);
   2 参数：
   3 sockfd：待连接套接字
   4 backlog：最大同时接收连接请求个数
   5 返回值：
   6 成功：0，并将 sockfd 设置为监听套接字
   7 失败：-1
   ```

   

   接受连接请求（仅针对流式套接字）：建立套接字连接──connect()与accept()

   这两个**系统调用**用于完成一个完整相关的建立，其中connect()用于建立连接。accept()用于使服务器等待来自某客户进程的实际连接。

   ```
   待连接：
   1 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
   2 参数：
   3 sockfd：监听套接字
   4 addr：通用地址结构体，用以存储对端地址（IP+PORT）
   5 addrlen：参数 addr 的存储区域大小
   6 返回值：
   7 成功：已连接套接字（非负整数）
   8 失败：-1
   ```

   该函数是用来等待客户端连接的， 如果有新的客户端连接上来那么该函数会返回一个新的sockfd
   作为该客户端的连接套接字。
   如果把accept 写在循环体内部， 该函数会造成阻塞， 同时如果有多个客户端连接那么该函数会返
   回这些客户所对应的多个已连接套接字。

   连接对端监听套接字

   ```
   1 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
   2 参数：
   3 sockfd：待连接套接字
   4 addr：包含对端地址（IP+PORT）的通用地址结构体的指针
   5 addrlen：地址结构体大小
   6 返回值：
   7 成功：0
   8 失败：-1
   ```

   

   发送和接收数据：通过 `send` 和 `recv` 函数（对于 TCP 套接字）或 `sendto` 和 `recvfrom` 函数（对于 UDP 套接字）来发送和接收数据。

   ```
   向 TCP 套接字发送数据
   1
   2 ssize_t send(int sockfd, const void *buf, size_t len, int flags);
   3 参数：
   4 sockfd：已连接套接字
   5 buf：即将被发送的数据
   6 len：数据长度
   7 flags：发送标志。
   8 MSG_NOSIGNAL：当对端已关闭时，不产生 SIGPIPE 信号
   9 MSG_OOB：发送紧急（带外）数据，只针对 TCP 连接
   10 返回值：
   11 成功：已发送字节数
   12 失败：-1
   备注：
   当 flags 为 0 时，send 与 write 作用相同。
   
   从 TCP 套接字接收数据
   1
   2 ssize_t recv(int sockfd, void *buf, size_t len, int flags);
   3 参数：
   4 sockfd：已连接套接字
   5 buf：存储数据缓冲区
   6 len：缓冲区大小
   7 flags：接收标志
   8 MSG_OOB：接收紧急（带外）数据
   9 返回值：
   10 成功：已接收字节数
   11 失败：-1
   备注：
   当 flags 为 0 时，recv 与 read 作用相同。
   ```

   

   关闭 Socket：通信结束后，应用程序调用 `close` 函数关闭套接字。

   

   ```
   1、 断开本端连接套接字
   接口声明：int close(int fd);
   参数：
   fd：已连接套接字
   返回值：
   成功：0
   失败：-1
   备注：
   
   同时断开读端和写端
   
   2、 断开本端连接套接字
   接口声明：int shutdown(int sockfd, int how);
   参数：
   sockfd：已连接套接字
   how：断开方式。
   SHUT_RD：关闭读端
   SHUT_WR：关闭写端
   SHUT_RDWR：同时关闭读写端
   返回值：
   成功：0
   失败：-1
   备注：
   在只关闭一端的时候，另一端可以继续使用。
   ```

## 6、四种IO模型

### 6.1、socket 中有四种IO模型

#### 1、阻塞型IO

- 最常用/最简单/效率低
- 函数本身不具备阻塞属性，而是由于文件描述符本身导致函数阻塞。
- 在默认情况下Linux建立的socket套接都是阻塞的

读阻塞

1. 当套接字接收缓冲区中没有数据可以读取时调用 如 read/recv/recvfrom就会导致阻塞
2. 当有数据到达时，内核便会去唤醒进程，通过read等函数来访问数据
3. 如果进程阻塞过程中意外，那么进程将永远阻塞下去。

写阻塞

1. 发生写阻塞的机会比较少，一般出现在写缓冲区无法写入即将写入的数据时
2. 当无法写入数据时便会进入阻塞等待
3. 一旦发送的缓冲区拥有足够的空间，则内核会唤醒对应的进程进行写入操作
4. 而UDP协议中并不存在发送缓冲区满的情况，UDP套接字执行写操作时永远不会发生阻塞。

#### 2、非阻塞

- 可以设置进程不阻塞在IO操作上，需要轮询
- 占用CPU资源较大

1. 如果有一个IO操作不能马上完成则系统则会让我们的进程进入睡眠状态等待
2. 当我们将一个套接字设置为非阻塞模式时，则系统不会让我们的进程进入睡眠等待而是直接返回错误
3. 当一个程序使用非阻塞模式的套接字，他需要使用循环来不断检查文件描述如是否有数据可读
4. 应用程序不停循环判断将会消耗非常大的CPU资源，一般不推荐使用

#### 3、多路复用IO

- 同时对多个IO进行操作
- 可以设置在规定的时间内检测数据是否到达

1. 当应用程序同时处理多路数据的输入或输出时，若采用非阻塞模式，将达不到预期的效果

2. 如果采用非阻塞模式，对多个输入进行轮询可以实现，但CPU的消耗非常大

3. 如果使用多进程/多线程，将产生进程与线程同步互斥的问题使得程序变得非常复杂

4. 使用多路复用则是最佳的选择，他的基本思想是：

   先把所有需要监听等待的文件描述符添加到一个集合中，在规定的时间内等待集合中所有描述符数据的变化，如果超时则跳出或进入下一次等待

5. 如果在规定时间内文件描述符的数据有发生变化则把其他没有数据变化的描述符剔除到集合之外等待进行下一次的等待状态。

select()调用用来检测一个或多个套接字的状态。对每一个套接字来说，这个调用可以请求读、写或错误状态方面的信息。请求给定状态的套接字集合由一个fd_set结构指示。在返回时，此结构被更新，以反映那些满足特定条件的套接字的子集，同时， select()调用返回满足条件的套接字的数目，其调用格式如下：

```
定义函数:
7 int select(int n, fd_set * readfds, fd_set * writefds,
8 fd_set * exceptfds, struct timeval * timeout);
9 参数说明：
10 n --> 当前最大的描述符+1
11 readfds --> 读取描述符组
12 writefds --> 写入描述符组
13 exceptfds --> 其他描述符组
14 timeout --> 超时时间
15 返回值：
16 如果参数 timeout 设为 NULL 则表示 select ()没有 timeout.
17 超时 返回 0
18 发生错误 返回 -1
19
20 注意：
21 struct timeval
22 {
23 time_t tv_sec;
24 time_t tv_usec;
25 };
26
27 FD_CLR(inr fd, fd_set* set); 用来清除描述词组 set 中相关 fd 的位
28 FD_ISSET(int fd, fd_set *set); 用来测试描述词组 set 中相关 fd 的位是否为真
29 FD_SET(int fd, fd_set*set); 用来设置描述词组 set 中相关 fd 的位
30 FD_ZERO(fd_set *set); 用来清除描述词组 set 的全部位
```

```
多路复用关键代码：
1 // 配置超时时间
2 struct timeval time_val ;
3 time_val.tv_sec = 5 ;
4 time_val.tv_usec = 0 ;
5
6 // 设置多路复用集合
7 fd_set set ;
8 FD_ZERO(&set); // 清空 集合
9 FD_SET(connect_fd , &set); // 添加 套记字到集合中
10 FD_SET(STDIN_FILENO , &set); // 添加标准输入到集合中
11
12 // 找到描述符最大值
13 max_fd = connect_fd > STDIN_FILENO ? connect_fd : STDIN_FILENO ;
14 // 等待描述符状态变化并设置超时 5秒
15 select(max_fd+1, &set , NULL ,NULL, &time_val);
16
17 // 等待客户端发话
18 bzero(msg , 1024);
19 if(FD_ISSET(STDIN_FILENO, &set)) //检查时候标准输入描述符有数据到达
20 {
21 fgets(msg , 1024 , stdin); // 获取标准输入数据
22 send(connect_fd , msg , strlen(msg), 0 ); // 发送数据
23 }
24
25 if(FD_ISSET(connect_fd, &set)) // 检查是否套接字描述符有数据到达
26 {
27 recv(connect_fd , msg , 1024 , 0); // 从套接字获得数据并发送
28 printf("msg :%s \n");
29 }
```

#### 4、信号驱动型IO

- 属于一步通信方式
- 当socket中有数据到达时，通过发送信号告知用户







