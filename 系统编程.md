# 系统编程

## 1、在 Linux 中的进程和线程与 C++ 中的多线程编程有一些区别

1. **进程和线程的概念**：
   - 在 Linux 中，进程是程序的执行实例，每个进程都有自己独立的地址空间和资源，通过调度器进行管理。
   - 线程是进程内的执行单元，共享进程的地址空间和资源，可以看作是轻量级的进程。线程之间更轻量级，创建和销毁的开销更小。
2. **创建与销毁开销**：
   - 在 Linux 中，创建和销毁进程的开销相对较大，因为每个进程都有独立的地址空间和资源。
   - 线程的创建和销毁开销相对较小，因为线程共享进程的地址空间和资源。
3. **通信与同步机制**：
   - 在 Linux 中，进程之间通信和同步的机制包括管道、信号、共享内存、消息队列等。
   - 在 C++ 中的多线程编程中，线程之间通信和同步的机制包括互斥量、条件变量、原子操作等，也可以使用 C++11 标准库中提供的高级并发工具，如 `std::thread`、`std::mutex`、`std::condition_variable` 等。
4. **调度与并发控制**：
   - Linux 中的进程和线程都由操作系统的调度器进行调度和管理，可以同时运行多个进程和线程。
   - C++ 中的多线程编程可以通过控制线程的启动顺序、使用同步机制和锁来实现并发控制，但是具体的调度由操作系统决定。
5. **跨平台性**：
   - C++ 的多线程编程在不同平台上有着一致的接口，例如使用标准库中的 `std::thread`、`std::mutex` 等，因此具有很好的跨平台性。
   - Linux 中的进程和线程也可以在其他操作系统上运行，但是具体的实现可能会有所不同，需要针对不同的操作系统进行调整。

## 2、进程

### 2.1进程：

指的是一个程序文件被加载到内存中，并由CPU来执行其内部的指令以及处理数据的过程，进程是一个活的状态，也就具备了开始于结束的过程。

就是进程是程序的执行实例。

![image-20240419174744966](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240419174744966.png)

fork创建成功以后，在父进程中返回子进程id，在子进程中返回0.

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid;

    pid = fork(); // 创建子进程
    
    if (pid < 0) { // 如果 fork() 调用失败
        fprintf(stderr, "Fork failed\n");
        return 1;
    } else if (pid == 0) { // 子进程中
        printf("Child process: PID = %d\n", getpid());
        printf("Child process: Parent PID = %d\n", getppid());
        printf("Child process: Hello!\n");
        // 在子进程中执行其他任务
        // ...
    } else { // 父进程中
        printf("Parent process: PID = %d\n", getpid());
        printf("Parent process: Child PID = %d\n", pid);
        printf("Parent process: Hello!\n");
        // 在父进程中执行其他任务
        // ...
    }
    
    return 0;

}
Parent process: PID = 7039
Parent process: Child PID = 7040
Parent process: Hello!
Child process: PID = 7040
Child process: Parent PID = 1530
Child process: Hello!
```

```
execl 函数是一个在 UNIX/Linux 系统下的系统调用，用于执行一个新的程序。它会将当前进程替换为新程序，新程序从头开始执行，原先的程序代码被完全替换。

这个函数的原型如下：

int execl(const char *path, const char *arg0, ..., const char *argn, (char *)0);
path 参数是要执行的程序的路径。
arg0 到 argn 是要传递给新程序的参数，每个参数都是一个字符串。
最后一个参数必须是 (char *)0，用于表示参数列表的结束。
例如，下面的示例代码展示了如何使用 execl 函数调用 /bin/ls 程序，并传递参数 -l 给它：

#include <stdio.h>
#include <unistd.h>

int main() {
    // 执行 ls -l 命令
    execl("/bin/ls", "ls", "-l", (char *)0);

    // 如果 execl 执行成功，下面的代码不会被执行
    printf("This line will not be executed\n");
    return 0;
}
在这个示例中，execl 函数调用 /bin/ls 程序，并传递参数 -l 给它。如果 execl 执行成功，当前进程就会被替换为 /bin/ls 程序，而下面的 printf 语句将不会被执行。
```

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 子进程
        printf("Child process executing...\n");
        exit(123); // 子进程退出，返回状态码 123
    } else if (pid > 0) {
        // 父进程
        printf("Parent process waiting for child...\n");
        int status;
        waitpid(pid, &status, 0); // 等待指定 PID 的子进程结束，并获取其退出状态
        printf("Child process exited with status: %d\n", status);
    } else {
        // fork 出错
        perror("fork");
        exit(EXIT_FAILURE);
    }

    return 0;
}

Parent process waiting for child...
Child process executing...
Child process exited with status: 31488
```

## 3、进程间通信

进程间的通信（IPC）方式，总归起来主要有如下这些：

```
1，无名管道（PIPE）和有名管道（FIFO）。
2，信号（signal）。
3，system V-IPC 之共享内存。
4，system V-IPC 之消息队列。
5，system V-IPC 之信号量。
6，套接字。
```

### 1、管道（PIPE）

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int pipefd[2]; // 用于存放管道的文件描述符

    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork(); // 创建子进程

    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // 子进程
        close(pipefd[1]); // 关闭管道的写入端

        char buffer[100];
        read(pipefd[0], buffer, sizeof(buffer)); // 从管道读取数据
        printf("Child process received: %s\n", buffer);

        close(pipefd[0]); // 关闭管道的读取端
    } else {
        // 父进程
        close(pipefd[0]); // 关闭管道的读取端

        char message[] = "Hello from parent!";
        write(pipefd[1], message, sizeof(message)); // 向管道写入数据

        close(pipefd[1]); // 关闭管道的写入端
    }

    return 0;
}

Child process received: Hello from parent!
```

### 2、信号

![image-20240420112404692](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420112404692.png)

Linux 系统中有许多信号，其中前面 31 个信号都有一个特殊的名字，对应一个特殊的事件，这些
信号都是从 Unix 系统继承下来的，他们还有个名称叫“不可靠信号”，他们有
如下的特点：
1，非实时信号不排队，信号的响应会相互嵌套。
2，如果目标进程没有及时响应非实时信号，那么随后到达的该信号将会被丢弃。
3，每一个非实时信号都对应一个系统事件，当这个事件发生时，将产生这个信号。
4，如果进程的挂起信号中含有实时和非实时信号，那么进程优先响应实时信号并且会
从大到小依此响应，而非实时信号没有固定的次序。
后面的 31 个信号（从 SIGRTMIN[34] 到 SIGRTMAX[64]）是 Linux 系统新增的
实时信号，也被称为“可靠信号”，这些信号的特征是：
1，实时信号的响应次序按接收顺序排队，不嵌套。
2，即使相同的实时信号被同时发送多次，也不会被丢弃，而会依次挨个响应。
3，实时信号没有特殊的系统事件与之对应。



常用函数：

​		![image-20240420112558846](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420112558846.png)

![image-20240420112643339](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420112643339.png![image-20240420112650829](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420112650829.png)

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

// 全局标志，用于通知主循环结束
int running = 1;

void sigint_handler(int signum) {
    printf("Received SIGINT\n");
    // 设置 running 标志为 0，通知主循环结束
    running = 0;
}

int main() {
    // 设置 SIGINT 的处理函数为 sigint_handler
    signal(SIGINT, sigint_handler);

    printf("Sending SIGINT to myself...\n");
    // 向当前进程发送 SIGINT 信号
    kill(getpid(), SIGINT);

    // 主循环，直到收到 SIGINT 信号
    while (running) {
        sleep(1);
    }

    printf("Exiting...\n");
    
    return 0;
}


```

给进程发送信号并携带额外的数据：



![image-20240420114840227](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420114840227.png)

```
union sigval
 {
 	int sigval_int;
	void * sigval_prt;
};
```

![image-20240420113454854](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420113454854.png)

```
上函数的 act 参数比较复杂，其类型结构体 struct sigaction 的定义如下：

 struct sigaction
 {
     void (*sa_handler)(int);
     void (*sa_sigaction)(int, siginfo_t *, void *);
     sigset_t sa_mask;
     int sa_flags;
     void (*sa_restorer)(void);
 };
```

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig, siginfo_t *info, void *context) {
    printf("Signal %d received with value: %d\n", sig, info->si_value.sival_int);
}

int main() {
    struct sigaction sa;

    // 设置信号处理函数
    sa.sa_sigaction = handler;
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGUSR1, &sa, NULL);

    pid_t pid = getpid(); // 获取当前进程的进程 ID

    printf("My PID is: %d\n", pid);

    // 向当前进程发送 SIGUSR1 信号，并携带附加数据 123
    if (sigqueue(pid, SIGUSR1, (union sigval) {.sival_int = 123}) == -1) {
        perror("sigqueue");
        exit(EXIT_FAILURE);
    }

    sleep(1); // 等待信号处理函数执行

    return 0;
}

```

```
My PID is: 1234
Signal 10 received with value: 123
```

### 3、消息队列、共享内存和信号量

#### 3.1消息队列

`msgget` 是 Linux 下用于创建或打开消息队列的函数之一，它的原型如下：

```
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
```

- `key` 参数用于指定消息队列的键值，它是一个整数值，用于唯一标识消息队列。通常可以使用 `ftok` 函数来生成一个键值，也可以手动指定一个键值。

- ```
  msgflg
  ```

   

  参数用于指定消息队列的创建方式和权限。可以通过按位或运算来组合多个选项，常见的选项包括：

  - `IPC_CREAT`：如果不存在指定键值的消息队列，则创建一个新的消息队列。
  - `IPC_EXCL`：与 `IPC_CREAT` 一起使用时，如果指定键值的消息队列已经存在，则创建失败。
  - 权限标志：如 `IPC_PRIVATE` 表示创建一个私有的消息队列，只有创建进程可以访问。

`msgget` 函数的返回值是一个非负整数，称为消息队列标识符（`msqid`），用于后续操作消息队列的其他函数。如果创建或打开消息队列失败，则返回 -1，并设置 `errno` 来指示具体的错误原因。

下面是一个简单的示例代码，演示了如何使用 `msgget` 创建或打开一个消息队列：

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <errno.h>

#define MSG_KEY 1234

int main() {
    int msqid;

    // 创建或打开一个消息队列
    msqid = msgget(MSG_KEY, IPC_CREAT | 0666);
    if (msqid == -1) {
        perror("msgget");
        exit(EXIT_FAILURE);
    }

    printf("Message queue created or opened with msqid = %d\n", msqid);

    return 0;
}
```

在这个示例中，我们使用键值 `1234` 创建或打开一个消息队列，并指定权限为 `0666`，表示该消息队列可以被所有用户读写。





`msgsnd` 和 `msgrcv` 分别用于向消息队列发送消息和从消息队列接收消息。它们的原型如下：

```
#include <sys/msg.h>

int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

- `msgsnd` 函数用于向指定的消息队列 `msqid` 发送消息，消息内容由参数 `msgp` 指向的数据结构指定，消息大小为 `msgsz` 字节。`msgflg` 参数用于指定发送消息的行为，常见的选项包括：
  - `IPC_NOWAIT`：如果消息队列已满，不会阻塞进程，而是立即返回错误。
  - 0：如果消息队列已满，则阻塞当前进程，直到消息队列有足够的空间存放消息。
- `msgrcv` 函数用于从指定的消息队列 `msqid` 接收消息，接收到的消息存储在 `msgp` 指向的数据结构中，最大大小为 `msgsz` 字节。`msgtyp` 参数用于指定要接收的消息类型，如果为 0，则接收队列中的第一个消息。`msgflg` 参数用于指定接收消息的行为，常见的选项包括：
  - `IPC_NOWAIT`：如果消息队列为空，不会阻塞进程，而是立即返回错误。
  - 0：如果消息队列为空，则阻塞当前进程，直到消息队列中有消息可读。

`msgsnd` 和 `msgrcv` 函数的返回值分别表示操作成功时返回 0，失败时返回 -1，并设置 `errno` 来指示具体的错误原因。

下面是一个简单的示例代码，演示了如何使用 `msgsnd` 向消息队列发送消息，以及如何使用 `msgrcv` 从消息队列接收消息：

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <string.h>
#include <errno.h>

#define MSG_KEY 1234

struct msgbuf {
    long mtype; // 消息类型
    char mtext[256]; // 消息内容
};

int main() {
    int msqid;
    struct msgbuf msg;

    // 创建新的消息队列
    msqid = msgget(MSG_KEY, IPC_CREAT | 0666);
    if (msqid == -1) {
        perror("msgget");
        exit(EXIT_FAILURE);
    }

    // 向消息队列发送消息
    strcpy(msg.mtext, "Hello, this is a message.");
    msg.mtype = 1; // 消息类型为1
    if (msgsnd(msqid, &msg, strlen(msg.mtext) + 1, 0) == -1) {
        perror("msgsnd");
        exit(EXIT_FAILURE);
    }

    printf("Message sent: %s\n", msg.mtext);

    // 从消息队列接收消息
    if (msgrcv(msqid, &msg, sizeof(msg.mtext), 0, 0) == -1) {
        perror("msgrcv");
        exit(EXIT_FAILURE);
    }

    printf("Message received: %s\n", msg.mtext);

    return 0;
}

```

在这个示例中，我们先打开一个已存在的消息队列，然后向消息队列发送一条消息，接着从消息队列接收一条消息，并打印出发送和接收到的消息内容。

#### 3.2共享内存（SHM）



![image-20240420151735465](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420151735465.png)

共享内存是一种用于在进程之间共享数据的机制。在使用共享内存时，可以使用一组系统调用来创建、附加、分离和控制共享内存段。其中包括：

1. `shmget`: 用于创建共享内存段或获取已经存在的共享内存段的标识符。如果要创建新的共享内存段，需要指定共享内存的大小和权限。如果要获取已存在的共享内存段，只需提供共享内存的键值和访问权限即可。
2. ![image-20240420202031305](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420202031305.png)
3. `shmat`: 用于将共享内存段连接到调用进程的地址空间中，使得进程可以访问共享内存中的数据。调用成功后，`shmat` 返回一个指向共享内存段的指针，进程可以使用这个指针来访问共享内存中的数据。
4. `shmdt`: 用于将共享内存段与调用进程的地址空间分离，使得进程无法再访问共享内存中的数据。调用成功后，共享内存段仍然存在，但进程不能再访问其中的数据。
5. ![image-20240420202056729](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420202056729.png)
6. `shmctl`: 用于控制共享内存段的各种属性，如删除共享内存段、获取共享内存段的状态信息等。可以使用 `shmctl` 函数来删除不再需要的共享内存段，以释放系统资源。
7. ![image-20240420202146533](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420202146533.png)

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>

#define SHM_KEY 1234
#define SHM_SIZE 1024

int main() {
    int shmid;
    char *shmaddr;

    // 创建或获取共享内存段
    shmid = shmget(SHM_KEY, SHM_SIZE, IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    // 将共享内存映射到进程的地址空间
    shmaddr = shmat(shmid, NULL, 0);
    if (shmaddr == (char *) -1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // 写入数据到共享内存
    strcpy(shmaddr, "Hello, this is shared memory.");

    // 访问共享内存中的数据
    printf("Data read from shared memory: %s\n", shmaddr);

    // 解除共享内存映射
    if (shmdt(shmaddr) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    // 删除共享内存段（可选）
    if (shmctl(shmid, IPC_RMID, NULL) == -1) {
        perror("shmctl");
        exit(EXIT_FAILURE);
    }

    return 0;
}

```

#### 3.3信号量

信号量是一种用于进程间同步和互斥的机制，可以用于解决多个进程访问共享资源时可能出现的竞态条件问题。在Linux系统中，可以使用一组系统调用来操作信号量，其中包括：

1. `semget`: 用于创建一个新的信号量集或获取一个已存在的信号量集的标识符。需要指定信号量集中信号量的数量和权限。如果要获取已存在的信号量集，只需提供信号量集的键值和访问权限即可。
2. `semop`: 用于对信号量进行操作，包括增加、减少或等待信号量的值。通过指定一个结构体数组来指定对哪些信号量进行操作以及进行何种操作。可以在调用 `semop` 时指定操作的类型和信号量操作的数量。
3. `semctl`: 用于控制信号量集的各种属性，如删除信号量集、获取信号量集的状态信息等。可以使用 `semctl` 函数来删除不再需要的信号量集，以释放系统资源，或者获取信号量的当前值等。

这些函数通常与其他系统调用一起使用，以实现进程之间的同步和互斥。在使用信号量时需要小心处理临界区和竞态条件，以确保多个进程之间对共享资源的访问不会导致数据不一致或发生冲突。

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

// 定义一个共享资源
int shared_resource = 0;

// 定义信号量操作的结构体
struct sembuf sem_op;

// 共享资源的信号量标识符
int sem_id;

// 初始化信号量
void init_semaphore() {
    // 创建一个新的信号量集，包含一个信号量
    sem_id = semget(IPC_PRIVATE, 1, 0666 | IPC_CREAT);
    if (sem_id == -1) {
        perror("semget");
        exit(1);
    }

    // 设置信号量初始值为 1，表示互斥访问
    if (semctl(sem_id, 0, SETVAL, 1) == -1) {
        perror("semctl");
        exit(1);
    }
}

// 进入临界区
void enter_critical_section() {
    // 尝试获取信号量资源，如果信号量值大于 0，则进入临界区
    sem_op.sem_num = 0;
    sem_op.sem_op = -1; // 信号量值减 1
    sem_op.sem_flg = 0;
    if (semop(sem_id, &sem_op, 1) == -1) {
        perror("semop");
        exit(1);
    }
}

// 离开临界区
void leave_critical_section() {
    // 释放信号量资源，信号量值加 1
    sem_op.sem_num = 0;
    sem_op.sem_op = 1; // 信号量值加 1
    sem_op.sem_flg = 0;
    if (semop(sem_id, &sem_op, 1) == -1) {
        perror("semop");
        exit(1);
    }
}

// 增加共享资源的值
void increase_shared_resource() {
    shared_resource++;
}

// 减少共享资源的值
void decrease_shared_resource() {
    shared_resource--;
}

// 第一个进程的代码
void process1() {
    enter_critical_section();
    increase_shared_resource();
    printf("Process 1: Shared resource = %d\n", shared_resource);
    leave_critical_section();
}

// 第二个进程的代码
void process2() {
    enter_critical_section();
    decrease_shared_resource();
    printf("Process 2: Shared resource = %d\n", shared_resource);
    leave_critical_section();
}

int main() {
    // 初始化信号量
    init_semaphore();

    // 创建子进程
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        exit(1);
    } else if (pid == 0) {
        // 子进程执行 process1
        process1();
    } else {
        // 父进程执行 process2
        process2();
    }

    return 0;
}

```

信号量和共享内存实现两个进程之间的简单聊天

```
信号量配合共享内存使用
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <string.h>

#define SEM_KEY 1234
#define SHM_KEY 5678
#define SHM_SIZE 1024

int sem_id, shm_id;

// 信号量操作结构体
struct sembuf sem_op;

// 进入临界区
void enter_critical_section() {
    sem_op.sem_num = 0;
    sem_op.sem_op = -1;
    sem_op.sem_flg = 0;
    if (semop(sem_id, &sem_op, 1) == -1) {
        perror("semop");
        exit(1);
    }
}

// 离开临界区
void leave_critical_section() {
    sem_op.sem_num = 0;
    sem_op.sem_op = 1;
    sem_op.sem_flg = 0;
    if (semop(sem_id, &sem_op, 1) == -1) {
        perror("semop");
        exit(1);
    }
}

int main() {
    char *shm_ptr;

    // 创建信号量
    sem_id = semget(SEM_KEY, 1, IPC_CREAT | 0666);
    if (sem_id == -1) {
        perror("semget");
        exit(1);
    }

    // 初始化信号量值为 1
    if (semctl(sem_id, 0, SETVAL, 1) == -1) {
        perror("semctl");
        exit(1);
    }

    // 创建共享内存
    shm_id = shmget(SHM_KEY, SHM_SIZE, IPC_CREAT | 0666);
    if (shm_id == -1) {
        perror("shmget");
        exit(1);
    }

    // 连接共享内存
    shm_ptr = shmat(shm_id, NULL, 0);
    if (shm_ptr == (char *) -1) {
        perror("shmat");
        exit(1);
    }

    // 主循环
    while (1) {
        // 进入临界区
        enter_critical_section();

        // 从共享内存读取消息并打印
        printf("Received: %s\n", shm_ptr);

        // 如果收到 "exit"，则退出循环
        if (strcmp(shm_ptr, "exit") == 0) {
            break;
        }

        // 离开临界区
        leave_critical_section();

        // 输入要发送的消息
        printf("Enter message: ");
        fgets(shm_ptr, SHM_SIZE, stdin);

        // 删除输入消息中的换行符
        strtok(shm_ptr, "\n");

        // 进入临界区
        enter_critical_section();

        // 离开临界区
        leave_critical_section();
    }

    // 分离共享内存
    if (shmdt(shm_ptr) == -1) {
        perror("shmdt");
        exit(1);
    }

    // 删除共享内存
    if (shmctl(shm_id, IPC_RMID, NULL) == -1) {
        perror("shmctl");
        exit(1);
    }

    // 删除信号量
    if (semctl(sem_id, 0, IPC_RMID, 0) == -1) {
        perror("semctl");
        exit(1);
    }

    return 0;
}

```

## 4、多线程

线程基本概念

- 线程实际上是应用层的概念，在 Linux 内核中，所有的调度实体都被称为任务（task）他们之间的
- 区别是：有些任务自己拥有一套完整的资源，而有些任务彼此之间共享一套资源。

### 4.1 pthread_create函数

![image-20240420204611799](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240420204611799.png)

```
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_THREADS 5

// 线程函数
void *thread_function(void *thread_arg) {
    int tid = *((int *) thread_arg);
    printf("Hello from thread %d\n", tid);
    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_args[NUM_THREADS];
    int result_code, i;

    // 创建多个线程
    for (i = 0; i < NUM_THREADS; i++) {
        printf("Creating thread %d\n", i);
        thread_args[i] = i;
        result_code = pthread_create(&threads[i], NULL, thread_function, &thread_args[i]);
        if (result_code) {
            printf("Error creating thread: %d\n", result_code);
            exit(-1);
        }
    }

    // 等待所有线程结束
    for (i = 0; i < NUM_THREADS; i++) {
        result_code = pthread_join(threads[i], NULL);
        if (result_code) {
            printf("Error joining thread: %d\n", result_code);
            exit(-1);
        }
        printf("Thread %d finished\n", i);
    }

    pthread_exit(NULL);
}

```

### 4.2线程安全

System V 信号量和 POSIX 信号量是在 Linux 和类 Unix 系统中用于进程间同步的两种不同的机制。

System V 信号量：

System V 信号量是在 System V IPC（Inter-Process Communication，进程间通信）机制下提供的一种同步原语。它的特点包括：

- 使用 `semget` 函数创建信号量集合，该函数返回一个唯一的标识符。
- 使用 `semctl` 函数对信号量进行控制，如设置、获取信号量的值等。
- 使用 `semop` 函数进行操作，如增加、减少信号量的值等。
- 信号量集合是系统范围的，所有进程都可以访问。

System V 信号量适用于需要在多个进程之间共享的系统级资源的同步。

POSIX 信号量：

POSIX 信号量是 POSIX 标准中定义的一种同步原语，用于在进程间或线程间共享资源。它的特点包括：

- POSIX 信号量可以是有名的（named semaphore）或无名的（unnamed semaphore）。
- 有名信号量使用 `sem_open` 函数创建，并通过指定一个全局唯一的名称来标识。
- 无名信号量使用 `sem_init` 函数初始化，不需要指定名称，通常用于同一进程内的线程间同步。
- POSIX 信号量使用 `sem_wait`、`sem_post` 等函数进行操作，类似于 System V 信号量的 `semop` 函数。

有名信号量适用于进程间需要共享的资源的同步，而无名信号量适用于线程间需要共享的资源的同步。

比较：

1. **可移植性**：POSIX 信号量在 POSIX 兼容系统上更具可移植性，而 System V 信号量则可能不太适用于所有类 Unix 系统。
2. **命名**：POSIX 信号量可以有一个全局唯一的名称，而 System V 信号量没有这个概念，只能通过标识符进行访问。
3. **资源释放**：System V 信号量在程序结束后会自动释放，而 POSIX 信号量在不需要时需要手动删除，避免资源泄漏。
4. **功能**：POSIX 信号量通常更灵活，并且支持更多的特性，如超时、进程死锁检测等。

总的来说，system-V 的信号量功能强大，强大到臃肿啰嗦，如果在现实工作中不需要那些高级功能，建议使用接口清晰、逻辑简单的 POSIX 信号量。

### 4.3 POSIX信号量

 **POSIX 信号量：**

- POSIX 有名信号量：可以在进程之间使用（属于系统级别的资源，基本可以替代IPC中的信号量）
- POSIX 无名信号量：只能在进程的内部，线程之间互相使用（使用同一个内存区）

**POSIX 有名信号量**

- 这种有名信号量的名字由类似“/somename”这样的字符串组成，注意前面有一个正斜杠，这样的信号量其实是一个特殊的文件，创建成功之后将会被放置在系统的一个特殊的虚拟文件系统/dev/shm 之中，不同的进程间只要约定好一个相同的名字，他们就可以通过这种有名信号量来相互协调。
- 值得一提的是，有名信号量跟 system-V 的信号量都是系统范畴的，在进程退出之后他们并不会自动消失，而需要手工删除并释放资源。

**POSIX 有名信号量的一般使用步骤是：**

1，使用 sem_open( )来创建或者打开一个有名信号量。

2，使用 sem_wait( )和 sem_post( )来分别进行 P 操作和 V 操作。

3，使用 sem_close( )来关闭他。

4，使用 sem_unlink( )来删除他，并释放系统资源。

| ![image-20240506211736154](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240506211736154.png) |
| :----------------------------------------------------------: |
| ![image-20240506211749188](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240506211749188.png) |
| ![image-20240506211800644](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240506211800644.png) |

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <semaphore.h>
#include <fcntl.h>

#define SHARED_MEMORY_SIZE 1024
#define SEMAPHORE_NAME "/my_semaphore"

int main() {
    int shm_id;
    char *shm_ptr;
    sem_t *sem;

    // 创建共享内存
    shm_id = shmget(IPC_PRIVATE, SHARED_MEMORY_SIZE, IPC_CREAT | 0666);
    if (shm_id == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    // 将共享内存映射到进程地址空间
    shm_ptr = (char *)shmat(shm_id, NULL, 0);
    if (shm_ptr == (char *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // 创建有名信号量
    sem = sem_open(SEMAPHORE_NAME, O_CREAT | O_EXCL, 0666, 1);
    if (sem == SEM_FAILED) {
        perror("sem_open");
        exit(EXIT_FAILURE);
    }

    // 写入数据到共享内存
    sem_wait(sem); // P 操作
    sprintf(shm_ptr, "Hello, shared memory!");
    sem_post(sem); // V 操作

    printf("Data written to shared memory: %s\n", shm_ptr);

    // 分离共享内存
    if (shmdt(shm_ptr) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    // 删除信号量
    if (sem_unlink(SEMAPHORE_NAME) == -1) {
        perror("sem_unlink");
        exit(EXIT_FAILURE);
    }

    // 删除共享内存
    if (shmctl(shm_id, IPC_RMID, NULL) == -1) {
        perror("shmctl");
        exit(EXIT_FAILURE);
    }

    return 0;
}

```

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <semaphore.h>
#include <fcntl.h>

#define SEMAPHORE_NAME "/my_semaphore"

int main() {
    int shm_id;
    char *shm_ptr;
    sem_t *sem;

    // 获取共享内存 ID
    shm_id = shmget(IPC_PRIVATE, 0, 0666);
    if (shm_id == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    // 将共享内存映射到进程地址空间
    shm_ptr = (char *)shmat(shm_id, NULL, 0);
    if (shm_ptr == (char *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // 打开已存在的信号量
    sem = sem_open(SEMAPHORE_NAME, 0);
    if (sem == SEM_FAILED) {
        perror("sem_open");
        exit(EXIT_FAILURE);
    }

    // 读取共享内存中的数据
    sem_wait(sem); // P 操作
    printf("Data read from shared memory: %s\n", shm_ptr);
    sem_post(sem); // V 操作

    // 分离共享内存
    if (shmdt(shm_ptr) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    return 0;
}

```

**POSIX 无名信号量**

如果我们要解决的是一个进程内部的线程间的同步互斥，那么也许不需要使用有名信号量，因为这些线程共享同一个内存空间，我们可以定义更加轻量化的、基于内存的（不在任何文件系统内部）无名信号量来达到目的。

这种信号量的使用步骤是：

1，在这些线程都能访问到的区域定义这种变量（比如全局变量），类型是 sem_t。

2，在任何线程使用它之前，用 sem_init( )初始化他。

3，使用 sem_wait( )/sem_trywait( )和 sem_post( )来分别进行 P、V 操作。

4，不再需要时，使用 sem_destroy( )来销毁他。

### 4.4 互斥锁与条件变量

当我们实现的路基为互斥的逻辑时可以使用互斥锁来实现

操作步骤：

1. 初始化互斥锁资源 pthread_mutex_init（）

2. 访问某个资源之前先上锁 pthread_mutex_lock（）

3. 访问结束后应该解锁 pthread_mutex_unlock（）

4. 当不再使用的时候应该销毁到锁资源 pthread_mutex_destroy ( )

**读写锁**

使用互斥锁的时候， 可以有效的保护某一个共共享资源， 使得该资源在任何情况下都只能有一个

线程在访问。如果出现多个线程进行读取某一资源的时候就会造成多个线程在获取该资源是阻塞等

待， 导致程序的效率降低。

因此以以上情况中，如果某一个资源有可能在同一时间内会有多个线程进行同时访问，那么就可以

使用读写锁。

读锁：在同一时间内允许有多个线程进行读取资源，可以同时添加多个读锁

写锁：在同一个时间内只允许有一个线程进行读取资源， 不允许有其它线程持有锁资源

操作步骤：

1. 初始化读写锁pthread_rwlock_init（）

2. 添加读锁 / 写锁pthread_rwlock_rdlock / pthread_rwlock_wrlock

3. 当不再使用共享资源的时候解锁pthread_rwlock_unlock（）

4. 当不需要使用读写锁时可以销毁pthread_rwlock_destroy()

```
#include <stdio.h>
#include <pthread.h>

#define BUFFER_SIZE 10

int buffer[BUFFER_SIZE];
int count = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t buffer_not_full = PTHREAD_COND_INITIALIZER;
pthread_cond_t buffer_not_empty = PTHREAD_COND_INITIALIZER;

void *producer(void *arg) {
    int item = 0;
    while (1) {
        pthread_mutex_lock(&mutex);
        if (count == BUFFER_SIZE) {
            pthread_cond_wait(&buffer_not_full, &mutex);
        }
        buffer[count++] = item++;
        printf("Produced item: %d\n", item);
        pthread_cond_signal(&buffer_not_empty);
        pthread_mutex_unlock(&mutex);
    }
}

void *consumer(void *arg) {
    while (1) {
        pthread_mutex_lock(&mutex);
        if (count == 0) {
            pthread_cond_wait(&buffer_not_empty, &mutex);
        }
        int item = buffer[--count];
        printf("Consumed item: %d\n", item);
        pthread_cond_signal(&buffer_not_full);
        pthread_mutex_unlock(&mutex);
    }
}

int main() {
    pthread_t producer_thread, consumer_thread;

    pthread_create(&producer_thread, NULL, producer, NULL);
    pthread_create(&consumer_thread, NULL, consumer, NULL);

    pthread_join(producer_thread, NULL);
    pthread_join(consumer_thread, NULL);

    return 0;
}

```

