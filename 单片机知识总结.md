# 单片机知识总结

## 1、GPIO模式

![image-20240423220810804](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240423220810804.png)

## 2、外部中断

中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行

中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源

中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回

![image-20240423223105274](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240423223105274.png)

AFIO主要用于引脚复用功能的选择和重定义,在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择

STM32 的中断向量具有两个属性，一个为抢占属性，另一个为响应属性，

```
其属性编号越小，表明它的优先级别越高。
```

抢占，是指打断其他中断的属性，即因为具有这个属性会出现嵌套中断（在执行中断服务函数A 的过程中被中断B 打断，执行完中断服务函数B 再继续执行中断服务函数A），抢占属性由NVIC_IRQChannelPreemptionPriority 的参数配置。
而响应属性则应用在抢占属性相同的情况下，当两个中断向量的抢占优先级相同时，如果两个中断同时到达， 则先处理响应优先级高的中断， 响应属性由NVIC_IRQChannelSubPriority 参数配置。例如，现在有三个中断向量，如下表。

## 3、定时器

TIM（Timer）定时器

定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断

16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时

不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能

根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型

![image-20240424160501046](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240424160501046.png)

STM32F1系列微控制器提供了多种定时器模块，包括：

2个 基本定时器（TIM6和TIM7）：用于生成简单的定时中断，适用于一些简单的定时任务。
4个 通用定时器（TIM2至TIM5）：具有更多的功能和配置选项，可以实现更复杂的定时任务和PWM输出等功能。
2个 高级定时器（TIM1、TIM8）：功能最为丰富的定时器，可以用于高级的PWM控制、编码器接口、脉冲捕获等应用。
通用定时器通常挂接在APB1；
高级定时器通常挂载在AHB上。

2. 通用定时器简介
STM32F1的通用定时器包含一个 16位 自动重载计数器（CNT），该计数器由可编程预分频器（PSC）驱动。
通用定时器支持多种工作模式，包括定时器模式、定时器中断模式、PWM输出模式、输入捕获模式和输出比较模式等。

使用定时器预分频器和RCC时钟控制器预分频器，脉冲长度和波形周期可以在几个微秒至几个毫秒间调整。
通用定时器框图
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/52911911a1e8433098928ba5c2cde1a9.png)

（1）时基单元
通用定时器的时基单元是指定时器的基本计时单元，它决定了定时器计数的频率和精度。时基单元包括 ：

计数器寄存器（TIMx_CNT），16位；
预分频器寄存器（TIMx_PSC），16位，在1~65535之间取值；
自动装载寄存器（TIMx_ARR）。
预分频系数用来将定时器的时钟频率降低到一个合适的范围，以适应具体的应用需求，它的值是一个正整数，通常可以通过以下公式来计算：



（2）计数器模式
根据所选的计数器模式，定时器的计数器将以不同的方式进行计数。

在向上计数模式下，计数器从0开始递增；
在向下计数模式下，计数器从自动重装载值开始递减；
在中央对齐模式和双边沿对齐模式下，计数器的溢出值为自动重装载值的一半。
不同的计数器模式适用于不同的应用场景，可以根据具体的需求选择合适的模式来实现相应的功能。

（3）时钟选择
通用定时器的时钟决定了定时器的计数速率和精度。在STM32微控制器中，通用定时器可以选择多种时钟源，包括内部时钟源和外部时钟源。

常见的时钟源：

内部时钟源（Internal Clock Source）：内部时钟源是由微控制器内部的时钟模块提供的时钟信号，通常为主时钟（HCLK）或高速内部时钟（HSI）。内部时钟源具有稳定性好、可靠性高的优点，适用于大多数应用场景。

外部时钟源（External Clock Source）：外部时钟源是由外部晶振或外部时钟信号提供的时钟信号，通常通过外部引脚输入到微控制器内部。外部时钟源具有精度高、抗干扰能力强的特点，适用于对时钟精度有较高要求的应用场景。
![image-20240424164516815](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240424164516815.png)

## 4、pwm介绍

OC（Output Compare）输出比较
输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形
每个高级定时器和通用定时器都拥有4个输出比较通道
高级定时器的前3个通道额外拥有死区生成和互补输出的功能

![image-20240424165325655](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240424165325655.png)

![image-20240424165359896](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240424165359896.png)

![image-20240424165427047](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240424165427047.png)

PWM的频率=计数器的更新频率

若要产生一个频率为1kHz,占空比为50%，分辨率为1%的PWM波形

带入公式：72M/(PSC+1)/(ARR+1)=1000

                  CCR/(ARR+1) = 50%
    
                  1/(ARR+1)=1%

则计算出：ARR+1=100,CCR=50,PSC+1=720 


![image-20240424165510517](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240424165510517.png)

舵机要求的频率：20ms，故为50Hz
占空比:舵机要求高电平时间是0.5ms~2.5ms
计算出来的PSC和ARR不固定
测试PSC+1=72，ARR+1=20k时比较方便，此时，CCR=500，则0.5ms，CCR=2500，则2.5ms
CCR=500,0度，CRR=2500，180度

## 5、IC（Input Capture）输入捕获

输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数
每个高级定时器和通用定时器都拥有4个输入捕获通道
可配置为PWMI模式，同时测量频率和占空比
可配合主从触发模式，实现硬件全自动测量

![image-20240424165940646](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240424165940646.png)

![image-20240424165954021](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240424165954021.png)

```
• PWM 频率：   Freq = CK_PSC / (PSC + 1) / (ARR + 1)
• PWM 占空比：   Duty = CCR / (ARR + 1)
• PWM 分辨率：   Reso = 1 / (ARR + 1)
CK_PSC为72M，PSC为预分频器，ARR为自动重装器，CCR为捕获/比较器
改变PSC和ARR都可以调节频率，但改变ARR调节频率会影响到占空比，所以选择PSC调节频率
```

 TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;        //ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1;        //PSC
    TIM_OCInitStructure.TIM_Pulse = 0;        //CCR

这代码中，因为ARR=100,所以CCR的值为占空比（该电平在周期的比例）

3、单独修改PSC的函数
void PWM_SetPrescaler(uint16_t Prescaler)
{
	//第三个参数指定定时器预分屏器的重装模式
	//第一个 TIM_PSCReloadMode_Update,预分频器在更新事件重装//等待周期结束
	// 第二个TIM_PSCReloadMode_Immediate预分频器立即重装//可能一个周期没结束就切换
	TIM_PrescalerConfig(TIM2, Prescaler, TIM_PSCReloadMode_Immediate);
}

4、设置1000HZ，占空比为50%
	PWM_SetPrescaler(720 - 1);		//Freq = 72M / (PSC + 1) / 100  //1000hz
	PWM_SetCompare1(50);			//Duty = CCR / 100        //占空比为50%

5、工作步骤

```
第一步：RCC开启时钟,打开GPIO和TMI的时钟
第二步：GPIO初始化,配置成输入模式，一般选择上拉输入或者浮空输入模式
第三步：配置时基单元，让CNT计数器在内部时钟的驱动下自增运行
第四步：配置输入捕获单元，包括滤波器、级联、直联通道还是交叉通道、分频器等参数，用结构体统一进行配置
第五步：选择重模式的触发源，触发源选择为TI1FP1(此处调用一个库函数，给个参数即可)
第六步：选择触发之后执行的操作：执行RESET操作（调用库函数）
最后，调用TIM_CMD函数开启定时器

```

> 想要获取一个周期的频率时，直接读取CCR计算器，然后按照fc除N计算即可（fc，标准频率=72M/预分频系数）

6、CCR

> 输入捕获模式下：CCR是只读的，要用GetCapture读出
>
> 输出比较模式下：CCR是只写的，要用SetCompare1

## 6、编码器

1、Encoder Interface 编码器接口的工作流程

编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度

![img](https://img-blog.csdnimg.cn/2a94f1b47a01445993559193f9e7bab8.png)

2、编码器接口举例子讲解
若初始化之后CNT初始值为0，右转产生10个脉冲后停下来，CNT就由0自增到10停下来
再让编码器在左转产生5个脉冲，那CNT就在原来10的基础上自减5停下来
编码器接口：相当于一个带有方向控制的外部时钟，它同时控制着CNT的计数时钟和计数方向，CNT的值就表示了编码器的位置
若每隔一段时间取是CNT的值，再把CNT清零，每次取出来的值就表示了编码器的速度



3、编码器测速（带方向的测速）实质
实质：测频法测正交脉冲的频率

CNT计次，然后每隔一段时间去一次计次，其实是测频法的思路



4、其他知识点
每个高级定时器和通用定时器都拥有1个编码器接口
两个输入引脚借用了输入捕获的通道1和通道2（通道3和通道4不能用）
如果一个定时器配置成了编码机接口模式，则基本干不了其他活，C816芯片只有（TIM1、TIM2、TIM3、TIM4，4个定时器，故最多只能接4个编码器，接完后就没定时器可以用了

![img](https://img-blog.csdnimg.cn/9f1843d97f5548abbf88ddd0695d4f2f.png)

（1）方波的频率代表速度 

（2）用正交信号的好处：
a、正交信号精度更高，因为A、B相都可以计次，相当关于计次频率提高了一倍

b、其次正交信号可以以抗噪声，因为正交信号两个信号必须是交替跳变的，可以设计一个抗噪声电路，如果一个信号不变，另一个信号连续跳变，也就是产生了噪声，这时计次值是不会变化的

（3）编码器接口的设计逻辑：
首先把A相和B相的所有边缘，作为计数器的计数时钟，出现边缘信号时就计数自增或自减，增还是减由另一相的高低电平决定

（4）定时器中的编码器


 编码器接口有使用CH1和CH2的输入捕获滤波器和边沿检测，编码器接口没有使用后面的是否交叉、预分频器、CCR寄存器与编码器接口无关

编码器接口的输出部分：相当于从模式控制器，去控制CNT的计数时钟和计数方向

6、编码器接口基本结构

![img](https://img-blog.csdnimg.cn/87a86926bad445f095f1ad705ec88897.png)

 7、工作模式

![img](https://img-blog.csdnimg.cn/3a5a407aeb5d45a689c4ba130d3acbe7.png)

```
想把65535——>-1，则把uint16_t写成int16_t（借助补码的方式）
```

1、功能：每隔一段时间去计数值，就能得到编码器旋转的速度

​    向右旋转：计数为正，想左旋转，计数为负，大小均为速度

​    现在：通过定时器的编码器接口，自动计次（节约软件资源）

​    之前：触发外部中断，在中断函数中自动计次

![img](https://img-blog.csdnimg.cn/e03e8f0f3760490d9b0c47344a9cae8b.png)

## 7、ADC模数转换

- ADC（Analog-Digital Converter）模拟-数字转换器
- ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁
- 12位逐次逼近型ADC，1us转换时间
- 输入电压范围：0~3.3V，转换结果范围：0~4095
- 18个输入通道，可测量16个外部和2个内部信号源
- 规则组和注入组两个转换单元
- 模拟看门狗自动监测输入电压范围

1、ADC、[DAC](https://so.csdn.net/so/search?q=DAC&spm=1001.2101.3001.7020)、PWM

![img](https://img-blog.csdnimg.cn/3a27c0fe64754a8e8ce193fdf94c085b.png)

- 左边是输入通道16个GPIO口外加2个内部的通道

- 进入AD转换器的两个组：规则组（最多选中16个通道）和注入组（最多选择4个通道），转换的结果存放在AD数据寄存器
- AD数据寄存器：规则组只有1个数据计算器，注入组有4个
- 触发控制：提供开始转换START信号,触发控制可以选择软件触发和硬件触发,硬件触发主要是来自于定时器,也可以选择外部中断的硬件
- RCC的ADC时钟CLOCK：推动ADC逐次比较的过程
- 模拟看门狗：监测转换结果的范围,如果超出设定的预值就通过中断输出控制,向NVIC申请中断
- 另外规则组和注入组转换完成后,会有个EOC信号,它置自己一个标志位，可以通向NVIC
- 开关控制：ADC_Cmd函数，给ADC上电的

## 8、DMA直接存储原理

1、DMA（Direct Memory Access）直接存储器存取

```
数据转运小助手，协助CPU完成数据转运工作，DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源

外设：一般指的是外设的数据计算器DR，data register，比如ADC的数据寄存器、串口的数据寄存器等等，

存储器：运行内存SRAM和程序存储器Flash，是存储变量数组和程序代码的地方

```

2、12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）

```
从一个地方移动到另一个地方，需要占用一个通道，DMA多通道进行运转时候，之间可以各转各的互不干扰
```

3、每个通道都支持软件触发和特定的硬件触发

```
若是存储器到存储器的数据转运，比如把flash里的一批数据转运到SRAM中去，就需要软件触发，触发后，DMA就会一股脑的转运，以最快的速度全部转运好
若是外设到存储器的数据转运，不能一股脑的转运，因为外设的数据是有一定时机的，需要硬件触发。比如转运ADC的数据，就得ADC每个通道AD转换完成后，硬件触发一次DMA，之后DMA再转运，触发一次转运一次,才能保证数据正确
特定的硬件触发：每个DMA的通道，它的硬件出发源是不一样的，当使用某个外设的硬件出发源，就得使用它连接的那个通道，而不能任意选择通道

```

4、STM32F103C8T6 DMA资源：DMA1（7个通道）

5、存储器映像

![img](https://img-blog.csdnimg.cn/a93a9bc746344afbbe6212e383ccc146.png)

（1）ROM(只读存储器)

- 一种非易失性、掉电不丢失的存储器
- 程序存储器flash(主闪存)的用途：存储c语言编译后的程序代码，也是下载程序的位置，运行程序一般也是从主闪存里面开始运行的，数据地址以0800开头的，为主闪存地址
- 系统存储器：BootLoader程序是芯片出厂自动写入的，一般不允许我们修改
- 启动加载器（BootLoader）是计算机系统中用于启动操作系统的程序。它位于计算机的非易失性存储器中，如硬盘驱动器、固态硬盘或闪存中。当计算机开机时，启动加载器首先被加载到内存中，并执行，然后它负责加载操作系统的内核到内存中，并将控制权转移到操作系统，使得操作系统能够开始运行。
- 选项字节：用于存储一些独立于程序代码的配置参数，位置是在ROM区的最后面，下载程序可以不刷新选项字节的内容，这样选项字节的配置就可以保持不变，选项字节里，存的主要是flash的读保护、写保护，还有看门狗等等的配置

（2）RAM(随机存储器)

- 一种易失性、掉电丢失的存储器
- 内核外设寄存器：内核外设就是NVIC和SysTick，内核外设和其他外设不是同个厂家设计的，所以地址被分开

6、寄存器读写

- CPU/DMA直接访问Flash，是可以读不可写
- SRAM是运行内存，可以任意读写
- 外设寄存器：看数据手册（数据寄存器是可以读写的）

7、DMA基本结构

![img](https://img-blog.csdnimg.cn/e2e6488416744ea9b6d6a2ee4c1407d5.png)

（1）两个站点：

外设寄存器站点（也是存储器，但是一般被叫做外设）
flash和SRAM存储器站点（stm32中存储器一般指flash和SRAM，不包含外设寄存器）
由于flash是只读的，所以只能是flash到SRAM的运转
（2）外设和存储器的三个参数

第一个是起始地址，有外设端的起始地址和存储器端的起始地址，这两个参数决定了数据是从哪里来，到哪里去的
第二个参数是数据宽度，指定一次转运要按多大的数据宽度来进行
字节Byte（8位，uint8_t）
半字节HalfWord（16位，uint16_t）
字Wold（32位，uint32_t）
第三个参数:地址是否自增，指定一次转运完成后，下一次转运是不是要把地址移动到下一个位置去，相当于是指针p++
比如ADC扫描模式用DMA进行数据转运，外设地址是ADC_DR寄存器，
外设寄存器地址不用自增，若自增，下次转运就跑到别的寄存器里了
存储器地址需要自增，没转运一个数据后，就往后挪，否则会把上次的数据覆盖掉
（3）两个站点的使用

如果是存储器到存储器的数据转运，需要把其中一个存储器的地址放在外设寄存器站点
外设寄存器只是个名字而已，可以写寄存器，如果写flash的地址，它就会去flash里找,写SRAM就会去SRAM里找
甚至可以两个站点换过来使用
（4）传输计数器

指定总共需要转运几次的，自减，例如写5，
DMA就只能进行5次数据转运，每转运一次减1，为0时，不再转运，之前自增的地址，会恢复到起始位置
（5）自动重装器

传输计数器减到0之后，是否要自动恢复到最初的值
若不使用，5次后结束，若使用，5次后，数据等于0时，立马重装成5，决定了单次还是循环模式，即重装则为循环（扫描模式加连续转换），不重装为单次
（6）DMA的触发控制

触发就是决定DMA需要在什么时机进行转运的。触发源有硬件触发和软件触发，
由M2M参数决定，1为软件触发，0为硬件触发     
软件触发
以最快的速度，连续不断地触发DMA,争取早日把传输计数清0，完成这一轮转换（和循环模式同时使用，因为软件触发是清0，循环模式是清0后自动重装，同时用，DMA停不下来）
适用于存储器到存储器的转运，因为存储器到存储器的触发时软件启动、不需要时机、并且想尽快完成任务                                                                                                       
硬件触发
硬件触发源可以选择ADC、串口收到数据、定时时间到等等，所以需要硬件触发
硬件达到时机时，传一个信号，来触发DMA进行转运
开关控制，给DMA使能后，DMA就准备就绪，可以进行转运
（7）DMA进行转运的条件

1、开关控制，DMA_Cmd必须使能
2、传输计数器必须大于0
3、触发源必须有触发信号，触发一次转运一次，传输计数器自减一次。当传输计数器等于0，且没有自动重装时，这时无论是否触发，DMA都不会再进行转运了
此时就需要DMA_Cmd给DISABLE,关闭DMA,再为传输计数器写一个大于0的数，在DMA_Cmd给Elable开启DMA，DMA才能继续工作，注意下写传输计数器时
必须要先关闭DMA再进行，不能在DMA开启时写传输计数器，这是手册里的规定

（8）DMA选择映象

![img](https://img-blog.csdnimg.cn/a99db1b377dc45f593eb9c9ec283c44a.png)

![img](https://img-blog.csdnimg.cn/3cbc101b001d44a2b6d16819d2a78748.png)

 8、数据转运+DMA

![img](https://img-blog.csdnimg.cn/676994b5a3ed433290fab1335d5c0e16.png)

 转运时，两边都要自增，要转运7次，所以传输计数器给7，自动重装暂时不需要，是存储器到存储器，要软件触发

9、ADC扫描模式+DMA

![img](https://img-blog.csdnimg.cn/c85651d9b3d54ebd857ade3668b9c62e.png)

触发后，7个通道依次进行AD转换，转换后的结果放在DC_DR数据寄存器中，在每个单独的通道转换完成后，进行一次DMA数据转运，并且目的地址进行自增，这样数据才不会覆盖 

此时DMA的配置：

外设地址写着ADC_DR这个寄存器的地址

存储器的地址可以在SRAM中定一个数组ADValue

然后把ADValue的地址当做存储器的地址，之后数据宽度

因为ADValue和SRAM数组要的是unit16_t的数据,所以数据宽度都是16位的,即半字传输

外设地址不自增，存储器地址自增，传输方向为外设站点到存储器站点

传输计数器：计次7次，因为由7个通道

计数器是否自动重装，取决ADC的配置，ADC如果是单次扫描,DMA不自动重装，连续扫描，DMA就自动重装

在ADC启动下一轮转换的时候，DMA也启动下一轮的转运，ADC和DMA同步工作

触发选择：这里ADValue的值是在ADC单个通道转换完成后才会有效，所以转运DMA时机，需要和ADC单个通道转换完成同步,故DMA的触发要选择ADC的硬件触发

硬件触发：在每个单独的通道转换完成后，没有任何标志位也不会触发中断，程序不太好判断某一个通道转换完成的时间

但虽然单个通道转换完成后，不产生任何标志位和中断。但是可能会产生DMA请求，去触发DMA转运

DMA数据转运&DMA+AD多通道

[16、江科大stm32学习笔记——DMA数据转运&DMA+AD多通道_stm32江科大笔记-CSDN博客](https://blog.csdn.net/weixin_45981798/article/details/129369412?ops_request_misc=%7B%22request%5Fid%22%3A%22171401191616800197036268%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=171401191616800197036268&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-19-129369412-null-null.nonecase&utm_term=江科大&spm=1018.2226.3001.4450)

## 9、usart串口协议和usart串口外设

1、通信接口

• 通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统

• 通信协议：制定通信的规则，通信双方按照协议规则进行数据收发

![img](https://img-blog.csdnimg.cn/92fac1081a044dd3b6010fe6239dfb0b.png)

-  异步：需要双方约定一个频率
- 双工：指在通信系统中，数据可以同时在两个方向上进行传输的一种通信方式。这意味着通信双方可以同时发送和接收数据，而不需要等待对方完成传输。这种方式可以实现实时的双向通信，例如电话通话或视频会议中的双方同时交流。
- 半双工通信是指通信系统中数据只能在两个方向的其中一个方向上进行传输的一种通信方式。换句话说，通信双方不能同时发送和接收数据，而是需要轮流进行发送和接收。这种通信方式类似于对讲机，其中一方发送消息时，另一方必须等待接收完毕后才能发送消息。

2、 硬件电路

• 简单双向串口通信有两根通信线（发送端 TX 和接收端 RX ）
• TX 与 RX 要交叉连接
• 当只需单向的数据传输时，可以只接一根通信线
• 当电平标准不一致时，需要加电平转换芯片
![img](https://img-blog.csdnimg.cn/fd1126d6669542b2aecb6351f817d6a1.png)

两个设备之间的[GND](https://so.csdn.net/so/search?q=GND&spm=1001.2101.3001.7020)一定要接在一起，但是VCC可以各自接。

3、电平标准

```
• TTL 电平： +3.3V 或 +5V 表示 1 ， 0V 表示 0
• RS232 电平： -3~-15V 表示 1 ， +3~+15V 表示 0
• RS485 电平：两线压差 +2~+6V 表示 1 ， -2~-6V 表示 0 （差分信号）

```

4、串口参数及时序

 波特率：串口通信的速率
速率的参数就是波特率，波特率就是每秒传输码元的个数，单位是码元/s（baud）
比特率：每秒传输的比特数，单位是bit/s,或者是bps
在二进制的情况下，一个码元及时一个bit，此时波特率等于比特率
• 起始位：标志一个数据帧的开始，固定为低电平
• 数据位：数据帧的有效载荷， 1 为高电平， 0 为低电平，低位先行
• 校验位：用于数据验证，根据数据位计算得来
• 停止位：用于数据帧间隔，固定为高电平

![img](https://img-blog.csdnimg.cn/be40b30ac466441dbca9eb0f82ef8e8a.png)

- 字节装载在数据帧中，数据帧由起始位、数据位、停止位组成

- 数据位有8个，代表一个字节的8位置，可以在最右边加一个奇偶校验位，则数据位总共是9位。接收方在接收数据后，会验证数据位和校验位
- 若规定发送的波特率是1000bps，表示1s要发1000位，每一位的时间就是1ms，发送方每隔1ms发送一位，接收方每隔1ms接受一位，决定了每隔多久发送一位
- 空闲状态下，起始位为高电平，起始位给低电平，使其产生下降沿，表示数据帧要开始

5、USART简介

• USART： 通用同步 / 异步收发器
• USART 是 STM32 内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从 TX 引脚发送出去，也可自动接收 RX 引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里.
• 自带波特率（一般设置为9600/115200）发生器，最高达 4.5Mbits/s
• 可配置数据位长度（ 8/9 ）、停止位长度（ 0.5/1/1.5/2 ）
• 可选校验位（无校验 / 奇校验 / 偶校验）
• 支持同步模式、硬件流控制、 DMA 、智能卡、 IrDA 、 LIN
同步模式：多了个时钟CLK的输出
• STM32F103C8T6 USART 资源： USART1（APB2总线上的设备） 、 USART2（APB1）、 USART3（APB1）
6、USART工作
（1）写操作

![img](https://img-blog.csdnimg.cn/e15efde55cad4aa8b534d39267ec82cc.png)


当数据移位完成后，数据会立刻自动从TDR发送移位寄存器

TDR和移位寄存器的双重缓存，保证在连续发送数据时，数据帧之间不会有空闲，提高了工作效率

（2）读操作

![img](https://img-blog.csdnimg.cn/e0f934ddfc334134b40327cb86a94f5d.png)


 因为串口协议规定是低位先行，所以接收移位寄存器时从高位往低位方向移动

（3）帧头和帧尾的添加和除由电路自动执行

（4）硬件数据控制流
A向B发送数据，当A一直发，B处理不过来；
若无硬件控制流，B只能抛弃新数据或者覆盖元数据；
有硬件控制流，硬件电路上会多出一条线，B没准备好置高电平，准备好置低电平；
A收到B的反馈决定数据发送，防止因为B处理慢而导致数据丢失。

![img](https://img-blog.csdnimg.cn/c4c59e581b724fa5a7cfed688c771c2d.png)


 能接收的时候，RTS就置低电平，请求对方发送，对方的CTS接收到后，就可以一直发

处理不过来时，RTS就置高电平，对方的CTS接收到后，就会暂停发送

（5）中断输出控制（USART）

![img](https://img-blog.csdnimg.cn/5f89b06884364f479889a482d78fbf39.png)


 TXE发送寄存器空，RXNE接收寄存器非空，是判断发送状态和接收状态的必要标志位
 中断输出控制就是配置中断是不是能通向NVIC

（6）波特率发生器

![img](https://img-blog.csdnimg.cn/e13af8723f5c4e8f84b8a901a7ffdfa0.png)


波特率发生器是分频器，APB时钟进行分频，得到发送和接收移位的时钟

时钟输入时fPCLKx（x=1或2），USART1挂载在APB2，所以就是PCLK2的时钟，为72M

其他的USART挂载在APB1，就是PCLK1的时钟,为36M

之后对时钟进行分频，除以USARTDIV的分频系数，分频后再除以16，得到发送器时钟和接收器时钟，通向控制部分

若TE=1,发送器使能，发送部分的波特率就有效

若RE=1,接收器使能，接收部分的波特率有效

 7、USART基本结构

![img](https://img-blog.csdnimg.cn/581f7deac1a24ff1b5687604ed5dbc31.png)

 8、数据帧

![img](https://img-blog.csdnimg.cn/71256b6446ce4a2693ca4b483bd74cda.png)


 有8位字长和9位字长，分别可以选择有校验和无校验

 9位建议有校验，8位建议无校验

 停止位有0.5，1，1.5，2，建于选择1位

9、波特率发生器

![img](https://img-blog.csdnimg.cn/5984bac340d344b480c8be30a71e220d.png)


发送器和接收器的波特率由波特率寄存器BRR里的DIV确定
计算公式：波特率 = fPCLK2/1 / (16 * DIV)//内部有16倍波特率的采样时钟 

配置USART1为9600的波特率
9600=72M（USART1的时钟）/(16*DIV）
DIV=72M/9600/16=468.75(二进制：11101 0100.11)
用库函数配置，需要多少波特率直接写就行

## 10、USART串口数据包

1、固定包长，含包头包尾（包尾不是必须的）

![img](https://img-blog.csdnimg.cn/4f219fc79b7a4640981feb3bf4965004.png)

2、可变包长，含包头包尾 

![img](https://img-blog.csdnimg.cn/58a7b43e600340b2a73c6d7e3b8d17c3.png)

```
1、包头包围和数据载荷重复的问题，传输的数据本身是FF和FE,可能引起误判
解决：限制载荷数据的范围，限幅（例如只发送0~100）
          如果无法避免数据于包头包尾重复，则尽量使用固定长度的数据包
          增加包头包尾的数量，尽量是其呈现出载荷数据出现不了的状态
2、包头包尾并不是全部都需要的，例如可以只要一个包头
3、固定包长和可变包长的选择问题
（1）对HEX来说，若载荷出现和包头包尾重复的情况，最好选择固定包长，避免接受错误
（2）若不重复，可以选择可变包长
4、各种数据转化为数据流的问题
数据包都是一个字节一个字节组成的，若想发送16位整型数据、32位整型数据，float、double、甚至是结构体（其内部都是由一个字节一个字节组成的），只需要用一个uint8_t的指针指向它，把数据当作字节数组发送即可

```

二、接收HEX数据包

![img](https://img-blog.csdnimg.cn/f6f4c0d3ac1241d58b5c6d3c5944c524.png)

每收到一个字节，函数都会进入一次中断，在[中断函数](https://so.csdn.net/so/search?q=中断函数&spm=1001.2101.3001.7020)中，可以拿到一个字节，但拿到字节之后，就得退出中断，故每拿到一个数据，都是一个独立的过程，而对数据包来说，有数据、包头、包尾三种状态，根据状态不同处理也不同

使用状态机收数据如上图

 三、发送文本数据包

![img](https://img-blog.csdnimg.cn/83e1b35b861242acb87fd9f0548db52f.png)

四、接收文本数据包

![img](https://img-blog.csdnimg.cn/438c22a4670546288d53f13ec5daf3dd.png)

五、HEX数据包和文本数据包的比较
（1）在hex数据包中，数据都是以原始的字节数据本身呈现的

（2）在文本数据包中，每个字节就经过一层编码和译码，最终表现出文本格式（文本背后还是一个字节的HEX数据） 

（3）hex数据包：传输直接、解析数据简单，适合一些模块发送原始的数据，比如一些使用串口通信的陀螺仪、温湿度传感器，但是灵活性不足、载荷容易和包头包尾重复

（4）文本数据包：数据直观易理解、灵活，适合一些输入指令进行人机交互，但解析效率低.

（5）发送100，hex直接发送一个字节100，而文本发送三个字节'1','0'.'0'，收到之后还要把字符转换程数据，才能得到100。

六、串口收发hex数据包&串口收发文本数据包

1、串口发送HEX数据包

```
void USART1_IRQHandler(void)
{
	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
	if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)		//判断是否是USART1的接收事件触发的中断
	{
		uint8_t RxData = USART_ReceiveData(USART1);				//读取数据寄存器，存放在接收的数据变量
		
		/*使用状态机的思路，依次处理数据包的不同部分*/
		
		/*当前状态为0，接收数据包包头*/
		if (RxState == 0)
		{
			if (RxData == 0xFF)			//如果数据确实是包头
			{
				RxState = 1;			//置下一个状态
				pRxPacket = 0;			//数据包的位置归零
			}
		}
		/*当前状态为1，接收数据包数据*/
		else if (RxState == 1)
		{
			Serial_RxPacket[pRxPacket] = RxData;	//将数据存入数据包数组的指定位置
			pRxPacket ++;				//数据包的位置自增
			if (pRxPacket >= 4)			//如果收够4个数据
			{
				RxState = 2;			//置下一个状态
			}
		}
		/*当前状态为2，接收数据包包尾*/
		else if (RxState == 2)
		{
			if (RxData == 0xFE)			//如果数据确实是包尾部
			{
				RxState = 0;			//状态归0
				Serial_RxFlag = 1;		//接收数据包标志位置1，成功接收一个数据包
			}
		}
		
		USART_ClearITPendingBit(USART1, USART_IT_RXNE);		//清除标志位
	}
}
```

2、串口收发文本数据包

```
void USART1_IRQHandler(void)
{
	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
	if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)	//判断是否是USART1的接收事件触发的中断
	{
		uint8_t RxData = USART_ReceiveData(USART1);			//读取数据寄存器，存放在接收的数据变量
		
		/*使用状态机的思路，依次处理数据包的不同部分*/
		
		/*当前状态为0，接收数据包包头*/
		if (RxState == 0)
		{
			if (RxData == '@' && Serial_RxFlag == 0)		//如果数据确实是包头，并且上一个数据包已处理完毕
			{
				RxState = 1;			//置下一个状态
				pRxPacket = 0;			//数据包的位置归零
			}
		}
		/*当前状态为1，接收数据包数据，同时判断是否接收到了第一个包尾*/
		else if (RxState == 1)
		{
			if (RxData == '\r')			//如果收到第一个包尾
			{
				RxState = 2;			//置下一个状态
			}
			else						//接收到了正常的数据
			{
				Serial_RxPacket[pRxPacket] = RxData;		//将数据存入数据包数组的指定位置
				pRxPacket ++;			//数据包的位置自增
			}
		}
		/*当前状态为2，接收数据包第二个包尾*/
		else if (RxState == 2)
		{
			if (RxData == '\n')			//如果收到第二个包尾
			{
				RxState = 0;			//状态归0
				Serial_RxPacket[pRxPacket] = '\0';			//将收到的字符数据包添加一个字符串结束标志
				Serial_RxFlag = 1;		//接收数据包标志位置1，成功接收一个数据包
			}
		}
		
		USART_ClearITPendingBit(USART1, USART_IT_RXNE);		//清除标志位
	}
}

```

![img](https://mmbiz.qpic.cn/sz_mmbiz_gif/2wyCFvAyEkLReAtPzmlqtgPeR7wb5EV7W0SSu433G4C7Lia9rBr2mfNFNClvVaaCPo2ibqqEcFjGYEryxKg4WOTg/640?wx_fmt=gif&wxfrom=13)

## 11、IIC通信

一、串口通信

-    只能在两个设备之间进行
-    若要三台设备两两通信，则每个设备得需要两组窗口，为3组相互独立的窗口通讯
-    为解决这个问题：设计了总线通讯，有多种，I2C为其中一种

二、I2C通信

（1）特点

- 1、同步、半双工
- 2、带数据应答
- 3、支持总线挂载多设备（一主多从、多主多从）
- 4、可以是软件IC和硬件IC

（2）时钟线和数据线

![img](https://img-blog.csdnimg.cn/0beaf305dfe04691b22b49e695f8865e.png)

1、主机：任何情况下，主机完全掌握SCL线，在空闲状态下，主机可以主动发起对SDA控制，只有在从机发送数据和从机应答时，主机才会转交SDA的控制权给从机

2、SCL时钟线在任何时刻都只能被动的读取，从机不允许控制SCL线,
3、SDA数据线，从机不允许主动发起对SDA的控制，只有在主机发送读取从机的命令后，从机应答的时候，从机才能短暂的获取SDA的控制权

4、主机拥有SCL的绝对控制权，所以主机的SCL可以配置成推挽输出，所有从机的SCL都配置成浮空输入或者上拉输入

5、为了实现输出输入半双工，避免总线没协调好导致电源短路，I2C规定禁止所有设备输出强上拉的高电平，采用外置若上拉电阻加开漏输出的电路

6、SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右

![image-20240426102728708](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240426102728708.png)

（3）SCL和SDA的状态

当SCL和SDA**都为高电平**，为**空闲状态**时（起始和终止都是由主机产生的，故空闲时，从机始终放开）

当SCL为高电平，SDA为**下降沿**的的状态时，为开始发送数据，**起始发送数据完成**

当SCL为高电平，SDA为**上升沿**的的状态时，**为数据发送完成**

**发送数据**的过程为下图

![image-20240425165358151](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240425165358151.png)

![image-20240425165645390](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240425165645390.png)

（4）例子：单片机向从设备写信息

![img](https://img-blog.csdnimg.cn/fa5486db743a4974b54029d1000c97ac.png)

假设上述是主机给24C02发送数据：
 由上图可知：
24C02的设备地址位1010 000，主机在24C02的 0000 0000的存储位置写入0000 1111的数据

- （1）读写数据位：读数据置1，写数据置0

- （2）第一个应答信号：信号时由从机发送给主机，如果从机收到之前的信息，回复0，没有收到或者（主机）读取接收完成回复1

- （3）第二个应答信号：单片机需要存储器返回一个应答信号

- （4）第三个应答信号：发送完数据后，需要再给主机发送应答信号0，告诉主机写入成功

- （5）最后写入停止位：SCL为高电平，SDA为上升沿

（5）读数据帧

![img](https://img-blog.csdnimg.cn/718b7a20f34945b6b6e9933bcd2ecea7.png)

        首先写入设备地址，然后写数据，
    
        接下来写寄存器的地址，在收到从机的应答信号之后，主机再发送一个起始号，       
    
        再发送一遍设备地址，然后才能发送读数据，接下来，存储器会把寄存器中的数据发送给单片机。
    
        最后一部分的数据可以多来几个，就可以写多个数据，地址指针在读后会自增，就可以连续读出一片区域的寄存器，效率也会变高。
    
        主机给应答：从机就会继续发，主机给非应答，从机不会再法发，交出SDA的控制权，从机控制SDA发送一个字节的权力，开始于读写标志位1，结束于主机给应答位为1
（6）开漏输出和推挽输出

![img](https://img-blog.csdnimg.cn/bb0651e15df648e1a92eeed15f640f9c.png)

任何设备在任何时刻都可以输入，但在输出部分，采用的是开漏输出
推挽输出：上面一个开关管接到正极，下面一个开关管接到负极，上面导通输出高电平，下面导通输出低电平,因为这是通过开关管直接接到正极和负极的，所以这个是强上拉和强下拉的模式
开漏输出：去掉强上拉的开关管，输出低电平时下面导通是强下拉，输出高电平时，下面断开但是没有上管了，引脚浮空，故所有设备只能输出低电平而不能输出高电平

![img](https://img-blog.csdnimg.cn/bf80815744d1481da4b42836ace3ba70.png)

为了避免高电平造成的引脚浮空，需要在总线外面SCL和SDA各置一个上拉电阻，弱上拉
开漏加弱上拉模式：同时兼具的输入和输出的功能
要输出时，就去拉杆子或者放手操作杆子变化就行了
要输入时，就直接放手然后观察杆子高低就行了
因为开路模式下，输出高电平就相当于断开硬件，所以在输入之前可以直接输出高电平，不需要再切换成输入模式
第三就是这个模式会有个“线与”的现象，只要有任意一个或多个设备，输出了低电平，，总线就处于低电平
只有所有的设备都输出高电平，总线才处于高电平

## 12、mpu6050实验

1.1 [MPU6050](https://so.csdn.net/so/search?q=MPU6050&spm=1001.2101.3001.7020)概述

飞行器通常搭载一款姿态传感器（不管是六轴还是九轴姿态传感器），本项目中以最常见的 MPU6050 为例。MPU6050 传感器其实并不能直接输出我们飞行器飞行过程中的欧拉角(Euler-angles)，通过读取它的传感器我们可以得到：3轴角速度+3轴角加速度。得到的角速度和角加速度信息我们是无法直接使用的，这个时候我们可以选择使用 DMP 去解算此时飞行器的欧拉角(Euler-angles)情况。当然，作者在项目中并没有使用 DMP 去解算飞行器的欧拉角(Euler-angles)，而是使用了四元数解算的方法！

![img](https://img-blog.csdnimg.cn/6d5cd04574564d0fb20424c75a21ae6b.png)

**DMP（Digital Motion Processor）**是一种数字运动处理器，它可以从MPU6050等传感器中读取数据，并进行解算以获取姿态信息。下面是DMP解算MPU6050的优缺点：

优点：

DMP使用简单，可以直接套用官方库进行开发，无需自己编写解算算法。
DMP不会占用太多的资源，因为它只需要读取传感器数据并进行简单的解算。
DMP的输出数据经过处理，可以直接用于姿态控制等应用，无需再进行复杂的计算。
缺点：

DMP的输出数据精度可能不够高，特别是在高精度传感场景下。
DMP的输出数据不稳定，可能会受到噪声等因素的影响。
DMP无法测量偏航角，只能获取滚动角和俯仰角的信息。

[基于STM32的四旋翼无人机项目（二）：MPU6050姿态解算（含上位机3D姿态显示教学）_stm32 mpu6050姿态解算-CSDN博客](https://blog.csdn.net/2301_76323084/article/details/137428086?ops_request_misc=%7B%22request%5Fid%22%3A%22171404656716777224415494%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=171404656716777224415494&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-137428086-null-null.nonecase&utm_term=mpu&spm=1018.2226.3001.4450)

![image-20240425204455429](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240425204455429.png)

![image-20240425204517405](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240425204517405.png)

![image-20240425204536271](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240425204536271.png)

使用官方的dmp库进行姿态角算解

```
//STM32F103C8T6+MPU6050姿态显示
//MPU6050接线： VCC->3V3
// 				GND->GND
// 				SCL->PB10
//				SDA->PB11
//USART1
//TX PA9
//RX PA10

int main(void)
{
	float pitch,roll,yaw; 	
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	
	uart_init(115200);	 	
	delay_init();	
	LED_Init();		  			
	MPU_Init();				
	while(mpu_dmp_init())
	{
		delay_ms(20);
	}
	while(1)
	{
		delay_ms(2);
		if(mpu_dmp_get_data(&pitch,&roll,&yaw)==0)
		{
			LED=~LED;
		}
		SEND_OULA_ANGLE((short)(-roll*100),(short)(pitch*100),(short)(-yaw*100));
	} 	
}
```

```
//mpu6050,dmp初始化
//返回值:0,正常
//    其他,失败
u8 mpu_dmp_init(void)
{
	u8 res=0;
	MPU_IIC_Init(); 	//初始化IIC总线
	if(mpu_init()==0)	//初始化MPU6050
	{	 
		res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);//设置所需要的传感器
		if(res)return 1; 
		res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL);//设置FIFO
		if(res)return 2; 
		res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	//设置采样率
		if(res)return 3; 
		res=dmp_load_motion_driver_firmware();		//加载dmp固件
		if(res)return 4; 
		res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//设置陀螺仪方向
		if(res)return 5; 
		res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	//设置dmp功能
		    DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
		    DMP_FEATURE_GYRO_CAL);
		if(res)return 6; 
		res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);	//设置DMP输出速率(最大不超过200Hz)
		if(res)return 7;   
		//res=run_self_test();		//自检
		if(res)return 8;    
		res=mpu_set_dmp_state(1);	//使能DMP
		if(res)return 9;     
	}else return 10;
	return 0;
}
//得到dmp处理后的数据(注意,本函数需要比较多堆栈,局部变量有点多)
//pitch:俯仰角 精度:0.1°   范围:-90.0° <---> +90.0°
//roll:横滚角  精度:0.1°   范围:-180.0°<---> +180.0°
//yaw:航向角   精度:0.1°   范围:-180.0°<---> +180.0°
//返回值:0,正常
//    其他,失败
u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
{
	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
	unsigned long sensor_timestamp;
	short gyro[3], accel[3], sensors;
	unsigned char more;
	long quat[4]; 
	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))return 1;	 
	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
	**/
	/*if (sensors & INV_XYZ_GYRO )
	send_packet(PACKET_TYPE_GYRO, gyro);
	if (sensors & INV_XYZ_ACCEL)
	send_packet(PACKET_TYPE_ACCEL, accel); */
	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
	**/
	if(sensors&INV_WXYZ_QUAT) 
	{
		q0 = quat[0] / q30;	//q30格式转换为浮点数
		q1 = quat[1] / q30;
		q2 = quat[2] / q30;
		q3 = quat[3] / q30; 
		//计算得到俯仰角/横滚角/航向角
		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
	}else return 2;
	return 0;
}
```

## 13、mpu6050与匿名上位机的通讯协议

![image-20240425212033066](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240425212033066.png)

```

//向上位机发送欧拉角
//详情参考匿名通讯协议
//滚动角（Roll）\俯仰角（Pitch）\偏航角（Yaw）
void SEND_OULA_ANGLE(short row,short pit,short yaw)
{
	u8 i;
	u8 sumcheck = 0;
	u8 addcheck = 0;
	u8 buf[13]={0};
	//上位机通信head为0xaa
	buf[0]=0xaa;
	//地址为0xff
	buf[1]=0xff;
	//id为0x03
	buf[2]=0x03;
	//长度为0x07
	buf[3]=0x07;
	
	buf[4]=(u8)row;
	buf[5]=(u8)(row>>8);
	
	buf[6]=(u8)pit;
	buf[7]=(u8)(pit>>8);

	buf[8]=(u8)yaw;
	buf[9]=(u8)(yaw>>8);
	//结束位为0x00
	buf[10]=0x00;
	
	for(i=0; i < (buf[3]+4); i++)
	{
		sumcheck += buf[i]; //从帧头开始，对每一字节进行求和，直到DATA区结束
		addcheck += sumcheck; //每一字节的求和操作，进行一次sumcheck的累加
	}
	buf[11]=sumcheck;//是将前面所有字节的值相加得到的结果。
	buf[12]=addcheck;//是将校验和 sumcheck 进行累加得到的结果。
	
	USART1_SEND_BUF_U8(buf,13);

	
}
```

## 14、硬件IIC实现

1、软件实现和硬件实现

- 串口通信为异步时序，用软件实现很麻烦，基本上用硬件实现

- 而I2C协议通信为同步时序，软件实现简单且灵活，硬件实现比较麻烦，故软件比较常用
- 但I2C硬件实现功能比较大，执行效率高，节省软件资源，可以实现完整的多主机通信模型，时序波形归整，通信速率快
- 故I2C软件实现用于简单环境，若性能要求高，则硬件实现

2、I2C外设简介 

- STM32 内部集成了硬件 I2C 收发电路，可以由硬件自动执行时钟生成、起始终止条件生成、应答位收发、数据收发等功能，减轻CPU的负担
- （软件只需要写入控制寄存器CR和数据寄存器DR，就可以实现协议，为了实现实时监控时序的状态，软件要读取状态寄存器SR）
- 支持多主机模型（固定多主机和可变多主机（stm32，谁要做主机，主机就得跳出来））
- 支持 7 位 /10位地址模式
- 支持不同的通讯速度，标准速度 ( 高达 100 kHz) ，快速 ( 高达 400 kHz)
- 支持 DMA（多字节传输时，提高效率）
- 兼容 SMBus 协议
- STM32F103C8T6 硬件 I2C 资源： I2C1 、 I2C2（两个独立I2C，硬件只有俩路I2C总线，而软件I2C只要代码存的下，想开几路就开几路）
- 本实验依旧是7位、一个主机 

3、硬件I2C外设引脚和[GPIO](https://so.csdn.net/so/search?q=GPIO&spm=1001.2101.3001.7020)复用关系

![image-20240425213645966](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240425213645966.png)



## 15、SPI通信协议原理

1、电路模式（采用一主多从的模式）、同步，全双工

<img src="https://img-blog.csdnimg.cn/1a4edfd8c0fc40a3a24e07d0e7ee1b33.png" alt="img" style="zoom:80%;" />

- ![image-20240426102823157](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240426102823157.png)

  所有SPI设备的SCK、MOSI、MISO分别连在一起

- 主机另外引出多条SS控制线，分别接到各从机的SS引脚

- 输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入

- 推挽输出：高低电平都有很强的驱动能力，使得SPI引脚信号的下降沿和上升沿非常迅速

- （IIC因为要实现半双工，经常切换输出输入，IIC又要实现多主机的时钟同步和总线仲裁，若使用推挽输出任意电源短路）

- SPI的MISO可能有冲突，一位内主机是输入，三个从机都是输出，若三个从机始终是推挽输出，势必会导致冲突。

- 故SPI有个规定：

  当从机的SS引脚为高电平时，即从机未被选中，其MISO引脚必须切换成高阻态，高阻态相当于引脚断开，不输出任何电平，这样可以防止一条线有多个输出，导致电平冲突问题

  SS为低电平时，MISO才允许变为推挽输出（切换在从机中，不需要关注）

 2、4条信号线

- SS（片选信号线（理解为从机选择线）、Slave Select）:单片机通过给片选信号线高低电平来确定哪一个从机通讯，一般当这根线为低电平时，片选才有效

- SCK（时钟信号线、Serial Clock）：主设备产生
- MOSI（发送信号线、Master Output Slave Input）:主设备从MOSI输出数据，而从设备通过MOSI接收数据
- MISO（接收信号线、Master Input Slave Output）：主设备通过这根线接收数据

3、通信过程

![image-20240426092844397](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240426092844397.png)

- 写数据：在地址为0x01处写数据0000 1111

- 给存储器发送起始位1，然后发送操作位01，然后地址0x01，数据0000 1111，则存储器的地址0x01就会保存0000 1111数据。
- 读取数据：
- 首先先写起始位1，然后操作码10，最后传递要取的地址符号
- spi是串行同步通信，因此数据线要和时钟线配合使用，才能给存储器发送数据



1.3 SPI的时序基本单元

![image-20240426094434957](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240426094434957.png)

交换字节（模式0，先移入，再移出）

  SPI外设的通信模式由控制寄存器中的CPOL（决定空闲时SCK的电平）和CPHA（时钟相位，决定第几个边沿采样）两个位控制。实际应用时，**模式0的应用最广泛。之后的实验也基于模式0进行。**

- CPOL=0：空闲状态时，SCK为低电平

- CPHA=0：SCK第一个边沿移入数据（进行电平检测），第二个边沿移出数据（将数据移到数据输出寄存器）。但是数据必须要先移出，再移入，所以在SS的下降沿时 ，主机就已经将数据输出到MOSI上了，所以这里可以理解为第0个SCK边沿移出，第1个SCK边沿移入。

![在这里插入图片描述](https://img-blog.csdnimg.cn/6eade47735d6401383740c89579275df.png#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/48efab47339444ecb417ac29131b8bb2.png#pic_center)

## 16、RTC实时时钟和备份寄存器BKP

vbat引脚提供备用电源

一、在STM32中，有五个时钟源，为HSI、HSE、LSI、LSE、PLL。

①HSI是高速内部时钟，RC振荡器，频率为8MHz。

②HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。

③LSI是低速内部时钟，RC振荡器，频率为40kHz。

④LSE是低速外部时钟，接频率为32.768kHz的石英晶体。

⑤PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。
![img](https://pic3.zhimg.com/80/v2-fd4c81e2695c58a08777c8ab76f03206_1440w.webp)

即检测HSE是否发生故障，如果有就切换到HSI然后给出相关信息

![image-20240502163658932](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502163658932.png)

- BKP（Backup Registers）备份寄存器
- BKP可用于存储用户应用程序数据。当VDD（2.0~3.6V）电源被切断，他们仍然由VBAT（1.8~3.6V）维持供电。当系统在待机模式下被唤醒，或系统复位或电源复位时，他们也不会被复位
- TAMPER引脚产生的侵入事件将所有备份寄存器内容清除
- RTC引脚输出RTC校准时钟、RTC闹钟脉冲或者秒脉冲
- 存储RTC时钟校准寄存器
- 用户数据存储容量：
- ​	20字节（中容量和小容量）/ 84字节（大容量和互联型）

![image-20240502163821758](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502163821758.png)

  

![image-20240502164603310](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502164603310.png)

<img src="C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502165616717.png" alt="image-20240502165616717" style="zoom: 67%;" />

一般使用LSE振荡器时钟提供给RTC

![image-20240502181313300](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502181313300.png)

执行以下操作将使能对BKP和RTC的访问：


若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC_CRL寄存器中的RSF位（寄存器同步标志）被硬件置1
必须设置RTC_CRL寄存器中的CNF位，使RTC进入配置模式后，才能写入RTC_PRL、RTC_CNT、RTC_ALR寄存器
对RTC任何寄存器的写操作，都必须在前一次写操作结束后进行。可以通过查询RTC_CR寄存器中的RTOFF状态位，判断RTC寄存器是否处于更新中。仅当RTOFF状态位是1时，才可以写入RTC寄存器

1、设置RCC_APB1ENR的PWREN和BKPEN，使能PWR和BKP时钟

```
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		//开启PWR的时钟
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);		//开启BKP的时钟
```

2、设置PWR_CR的DBP，使能对BKP和RTC的访问

```
	/*备份寄存器访问使能*/
	PWR_BackupAccessCmd(ENABLE);							//使用PWR开启对备份寄存器的访问
```

```

	while (1)
	{
		KeyNum = Key_GetNum();		//获取按键键码
		
		if (KeyNum == 1)			//按键1按下
		{
			ArrayWrite[0] ++;		//测试数据自增
			ArrayWrite[1] ++;
			
			BKP_WriteBackupRegister(BKP_DR1, ArrayWrite[0]);	//写入测试数据到备份寄存器
			BKP_WriteBackupRegister(BKP_DR2, ArrayWrite[1]);
			
			OLED_ShowHexNum(1, 3, ArrayWrite[0], 4);		//显示写入的测试数据
			OLED_ShowHexNum(1, 8, ArrayWrite[1], 4);
		}
		
		ArrayRead[0] = BKP_ReadBackupRegister(BKP_DR1);		//读取备份寄存器的数据
		ArrayRead[1] = BKP_ReadBackupRegister(BKP_DR2);
		
		OLED_ShowHexNum(2, 3, ArrayRead[0], 4);				//显示读取的备份寄存器数据
		OLED_ShowHexNum(2, 8, ArrayRead[1], 4);
	}
```

- 执行以下操作将使能对BKP和RTC的访问：
- ​	设置RCC_APB1ENR的PWREN和BKPEN，使能PWR和BKP时钟
- ​	设置PWR_CR的DBP，使能对BKP和RTC的访问
- 若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC_CRL寄存器中的RSF位（寄存器同步标志）被硬件置1
- 必须设置RTC_CRL寄存器中的CNF位，使RTC进入配置模式后，才能写入RTC_PRL、RTC_CNT、RTC_ALR寄存器
- 对RTC任何寄存器的写操作，都必须在前一次写操作结束后进行。可以通过查询RTC_CR寄存器中的RTOFF状态位，判断RTC寄存器是否处于更新中。仅当RTOFF状态位是1时，才可以写入RTC寄存器

```
void MyRTC_Init(void)
{
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		//开启PWR的时钟
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);		//开启BKP的时钟
	
	/*备份寄存器访问使能*/
	PWR_BackupAccessCmd(ENABLE);							//使用PWR开启对备份寄存器的访问
	
	if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)			//通过写入备份寄存器的标志位，判断RTC是否是第一次配置
															//if成立则执行第一次的RTC配置
	{
		RCC_LSEConfig(RCC_LSE_ON);							//开启LSE时钟
		while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);	//等待LSE准备就绪
		
		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);				//选择RTCCLK来源为LSE
		RCC_RTCCLKCmd(ENABLE);								//RTCCLK使能
		
		RTC_WaitForSynchro();								//等待同步
		RTC_WaitForLastTask();								//等待上一次操作完成
		
		RTC_SetPrescaler(32768 - 1);						//设置RTC预分频器，预分频后的计数频率为1Hz
		RTC_WaitForLastTask();								//等待上一次操作完成
		
		MyRTC_SetTime();									//设置时间，调用此函数，全局数组里时间值刷新到RTC硬件电路
		
		BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);			//在备份寄存器写入自己规定的标志位，用于判断RTC是不是第一次执行配置
	}
	else													//RTC不是第一次配置
	{
		RTC_WaitForSynchro();								//等待同步
		RTC_WaitForLastTask();								//等待上一次操作完成
	}
}
```

## 17、PWR电源控制

- PWR（Power Control）电源控制
- PWR负责管理STM32内部的电源供电部分，可以实现可编程电压监测器和低功耗模式的功能
- 可编程电压监测器（PVD）可以监控VDD电源电压，当VDD下降到PVD阀值以下或上升到PVD阀值之上时，PVD会触发中断，用于执行紧急关闭任务
- 低功耗模式包括睡眠模式（Sleep）、停机模式（Stop）和待机模式（Standby），可在系统空闲时，降低STM32的功耗，延长设备使用时间

PWR（电源）模块通常用于STM32微控制器中控制低功耗模式。在STM32Cube库中，包含了对不同低功耗模式的支持，包括睡眠模式（Sleep Mode）、停止模式（Stop Mode）和待机模式（Standby Mode）。让我简要解释一下它们：

1. **睡眠模式（Sleep Mode）**：
   - 在睡眠模式下，CPU暂停执行，并且大多数外设仍然保持活动状态，能够继续运行。
   - 主要用于快速进入低功耗模式，同时保持对外部事件的响应，例如定时器、UART接收等。
   - 通过设置特定的寄存器位来进入和退出睡眠模式。
2. **停止模式（Stop Mode）**：
   - 在停止模式下，CPU和大多数外设都停止工作，只有少数外设可以保持运行，例如RTC、WWDG等。
   - 主要用于进一步降低功耗，但仍然需要保持对某些外部事件的响应。
   - 通过设置特定的寄存器位来进入和退出停止模式。
3. **待机模式（Standby Mode）**：
   - 在待机模式下，系统的主时钟被关闭，所有外设都停止工作，只有RTC和WWDG（如果被使能）能够唤醒系统。
   - 主要用于极低功耗需求，例如在外部事件触发时唤醒系统，例如按键触发、外部中断等。
   - 进入待机模式通常需要一些预处理工作，例如关闭所有不必要的外设，设置唤醒源等。

在使用STM32Cube库时，可以使用相应的函数来进入和退出这些低功耗模式，例如使用`HAL_PWR_EnterSLEEPMode()`进入睡眠模式，`HAL_PWR_EnterSTOPMode()`进入停止模式，以及`HAL_PWR_EnterSTANDBYMode()`进入待机模式。

<img src="C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502192741585.png" alt="image-20240502192741585" style="zoom:67%;" />

<img src="C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502193648342.png" alt="image-20240502193648342" style="zoom:80%;" />

  

<img src="C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502194743905.png" alt="image-20240502194743905" style="zoom:80%;" />

睡眠模式+串口发送接收

```
if (Serial_GetRxFlag() == 1)			//检查串口接收数据的标志位
		{
			RxData = Serial_GetRxData();		//获取串口接收的数据
			Serial_SendByte(RxData);			//串口将收到的数据回传回去，用于测试
			OLED_ShowHexNum(1, 8, RxData, 2);	//显示串口接收的数据
		}
		
		OLED_ShowString(2, 1, "Running");		//OLED闪烁Running，指示当前主循环正在运行
		Delay_ms(100);
		OLED_ShowString(2, 1, "       ");
		Delay_ms(100);
		
		__WFI();								//执行WFI指令，CPU睡眠，并等待中断唤醒
```

停止模式

只能使用外部中断触发

```
int main(void)
{
	/*模块初始化*/
	OLED_Init();			//OLED初始化
	CountSensor_Init();		//计数传感器初始化
	
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		//开启PWR的时钟
															//停止模式和待机模式一定要记得开启
	
	/*显示静态字符串*/
	OLED_ShowString(1, 1, "Count:");
	
	while (1)
	{
		OLED_ShowNum(1, 7, CountSensor_Get(), 5);			//OLED不断刷新显示CountSensor_Get的返回值
		
		OLED_ShowString(2, 1, "Running");					//OLED闪烁Running，指示当前主循环正在运行
		Delay_ms(100);
		OLED_ShowString(2, 1, "       ");
		Delay_ms(100);
		
		PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);	//STM32进入停止模式，并等待中断唤醒
		SystemInit();										//唤醒后，要重新配置时钟
	}
}
```

待机模式

```
int main(void)
{
	/*模块初始化*/
	OLED_Init();		//OLED初始化
	MyRTC_Init();		//RTC初始化
	
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		//开启PWR的时钟
															//停止模式和待机模式一定要记得开启
	
	/*显示静态字符串*/
	OLED_ShowString(1, 1, "CNT :");
	OLED_ShowString(2, 1, "ALR :");
	OLED_ShowString(3, 1, "ALRF:");
	
	/*使能WKUP引脚*/
	PWR_WakeUpPinCmd(ENABLE);						//使能位于PA0的WKUP引脚，WKUP引脚上升沿唤醒待机模式
	
	/*设定闹钟*/
	uint32_t Alarm = RTC_GetCounter() + 10;			//闹钟为唤醒后当前时间的后10s
	RTC_SetAlarm(Alarm);							//写入闹钟值到RTC的ALR寄存器
	OLED_ShowNum(2, 6, Alarm, 10);					//显示闹钟值
	
	while (1)
	{
		OLED_ShowNum(1, 6, RTC_GetCounter(), 10);	//显示32位的秒计数器
		OLED_ShowNum(3, 6, RTC_GetFlagStatus(RTC_FLAG_ALR), 1);		//显示闹钟标志位
		
		OLED_ShowString(4, 1, "Running");			//OLED闪烁Running，指示当前主循环正在运行
		Delay_ms(100);
		OLED_ShowString(4, 1, "       ");
		Delay_ms(100);
		
		OLED_ShowString(4, 9, "STANDBY");			//OLED闪烁STANDBY，指示即将进入待机模式
		Delay_ms(1000);
		OLED_ShowString(4, 9, "       ");
		Delay_ms(100);
		
		OLED_Clear();								//OLED清屏，模拟关闭外部所有的耗电设备，以达到极度省电
		
		PWR_EnterSTANDBYMode();						//STM32进入停止模式，并等待指定的唤醒事件（WKUP上升沿或RTC闹钟）
		/*待机模式唤醒后，程序会重头开始运行*/
	}
}

```

## 18、WDG看门狗

- WDG（Watchdog）看门狗
- 看门狗可以监控程序的运行状态，当程序因为设计漏洞、硬件故障、电磁干扰等原因，出现卡死或跑飞现象时，看门狗能及时复位程序，避免程序陷入长时间的罢工状态，保证系统的可靠性和安全性
- 看门狗本质上是一个定时器，当指定时间范围内，程序没有执行喂狗（重置计数器）操作时，看门狗硬件电路就自动产生复位信号
- STM32内置两个看门狗
- ​	独立看门狗（IWDG）：独立工作，对时间精度要求较低
- ​	窗口看门狗（WWDG）：要求看门狗在精确计时窗口起作用

看门狗本质上是一个定时器

| ![image-20240502213309951](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502213309951.png) |
| ------------------------------------------------------------ |
| ![image-20240502213342333](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502213342333.png) |
| ![image-20240502213242020](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502213242020.png) |

## 19、Bootloader和OTA

1. **Bootloader**:
   - Bootloader是位于单片机内部的一段特殊的代码，其主要功能是在系统启动时初始化硬件并加载应用程序（固件）。
   - Bootloader通常包含一些基本的功能，例如从外部存储器（如闪存）中加载固件、进行固件验证、更新和擦除等。
   - Bootloader通常用于在设备启动时检查是否有新的固件可用，如果有，它可以加载并启动新的固件。如果没有新的固件，则它会启动现有的固件。
2. **OTA（Over-The-Air）**:
   - OTA是通过无线网络更新设备固件的一种方法，它允许您在设备不需要物理连接的情况下更新固件。
   - OTA功能通常需要在设备中实现一个用于接收和处理固件更新的协议。这通常涉及到设备与服务器之间的通信，并且要求设备能够下载、验证和应用新的固件。
   - OTA功能可以通过Wi-Fi、蓝牙、LoRa等无线通信方式实现，具体取决于设备的应用场景和需求。

## 20、内存简述（Flash和SRAM）

### 1、STM32内存简述

#### 1. STM32寻址范围

STM32是一个32位的单片机，因此，它有32根地址线，每个地址线有两种状态：导通 或 不导通。
单片机内存的地址访问存储单元是按照字节编址的。
按照字节编址，也就是说，访问一个地址上存储的数据，得到的是一个字节的数据。

根据上述两条，可以得出结论：

STM32的寻址（内存）大小为：2^32（字节） = 4G（字节）
STM32的寻址范围为：0X0000 0000 ~ 0XFFFF FFFF
.2. 存储器功能划分
上述存储地址被分为了8个块（目前我用到的芯片F1、F4、L4的都是，其他的没用过不确定）。
如下表所示：

![image-20240504153526174](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240504153526174.png)

#### 2. SRAM、ROM位置

简单说：

- RAM（随机存取存储器）：读写速度快、掉电数据丢失；类比于电脑内存的作用。
- ROM（只读存储器）：读写速度相对慢、掉电数据仍在；类比于电脑硬盘的作用

其中对于STM32而言，**SRAM就是内存；Flash就是硬盘**。

| <img src="https://img-blog.csdnimg.cn/fd43434f49984ed5a2474ac9c9b005b8.jpeg" alt="请添加图片描述" style="zoom:80%;" /> |
| ------------------------------------------------------------ |
| ![image-20240504155224310](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240504155224310.png) |

以最最最常见的STM32F103C8T6为例：

![请添加图片描述](https://img-blog.csdnimg.cn/174ae8290d864febae7115c4789f2f80.jpeg)

它的内置ROM起始地址为0X0800 0000，大小为0X10000，也就是FLASH的大小为：0X10000个字节 = 65536个字节 = 64k个字节 = 64kBytes。
它的内置RAM起始地址为0X2000 0000，大小为0X5000，也就是RAM的大小为：0X5000个字节 = 20480个字节 = 20k个字节 = 20kBytes。

![请添加图片描述](https://img-blog.csdnimg.cn/002d8a24dd464e9d97e8b2e927756d35.jpeg)

同样对比一下芯片的数据手册：可以看到，其中FLASH位于第一块（索引0）的中间区域，RAM1位于第二块（索引1）的开头，RAM2位于第一块（索引0）的中间区域。

| ![请添加图片描述](https://img-blog.csdnimg.cn/a24e8dc35ca24537b8c65b092c90090a.jpeg) |
| ------------------------------------------------------------ |

**地址0x1FFFF 0000到0x1FFF 7000**这部分，这部分是系统存储器，不需要我们用户来操作，但是要知道这部分出厂的时候就已经存了有东西的，后面看到Bootloader的时候会说到。



#### 3、程序占用内存大小

##### 3.1. 查看程序大小

使用 CubeMX 创建一个 stm32 工程，创建完成后什么也不写，直接使用 Keil 对编写的程序进行编译，编译完成之后，软件最下方会提示编写的程序所占空间的大小。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3055e40a0e204faebe5ce9603add7825.png)

也可以在工程目录中保存编译结果的文件夹中找到.map文件，在文件最下方查看更详细的信息。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e27fbbcd093a4f989f6eb05b1f886fc9.png)

##### 3.2. 占用内存分析

数据类型解释：

- Code：代码，也就是编译之后产生的机器指令。

- RO_data：Read Only data，只读数据域，指程序中用到的只读数据，这些数据被存储在ROM区，因而程序不能修改其内容。C语言中const关键字定义的变量就是典型的RO-data。这部分在程序运行过程中不能被更改，因此在运行时只需要来读取即可，无需占用 RAM 空间。
- RW_data：Read Write data，可读写数据域，指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。C语言中定义的全局变量，且定义时赋予“非0值”给该变量进行初始化。
- ZI_data：Zero Initialie data，即0初始化数据，它指初始化为“0值”的可读写数据域。它与RW-data的区别是程序刚运行时这些数据初始值全都为 0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。例如C语言中使用定义的全局变量，且定义时赋予“ 0 值”给该变量进行初始化(若定义该变量时没有赋予初始值，编译器会把它当ZI-data来对待，初始化为 0)；

再补充一个

- ZI-data 的栈空间(Stack)及堆空间(Heap)：在C语言中，函数内部定义的局部变量属于栈空间，进入函数的时候会向栈空间申请内存给局部变量，退出时释放局部变量，归还内存空间。而使用malloc动态分配的变量属于堆空间。在程序中的栈空间和堆空间都是属于ZI-data区域的，这些空间都会被初始值化为0值。编译器给出的ZI-data占用的空间值中包含了堆栈的大小(经实际测试，若程序中完全没有使用malloc动态申请堆空间，编译器会优化，不把堆空间计算在内)。


上述四种类型的数据占用内存情况如下：

- 在程序烧录完成之后如左图所示。Code + RO_data + RW_data（RO + RW）三种类型需要占用 Flash 空间。RAM不需要用到。

- 在程序运行时的情况如右图所示。Flash 的空间未发生变化；对于RAM的空间，程序启动时首先需要把 Flash 中的 RW_data（RW）复制到 RAM 中，然后把 ZI_data 加载到 RAM中。

<img src="https://img-blog.csdnimg.cn/274c6d4ca72a4efea5b6255c9c82ba1a.png" alt="在这里插入图片描述" style="zoom:80%;" />

对应到具体的内存上，结合启动流程如下图所示。

<img src="https://img-blog.csdnimg.cn/34421696aee540259dc4d17567617564.png" alt="在这里插入图片描述" style="zoom:67%;" />

结论，想要让一个程序正常运行。

- 芯片的 Flash 大小 要大于 Code + RO-data + RW-data 的大小；
- 芯片的 RAM 大小 要大于 RW-data + ZI_data 的大小。

#### 4. text、data、bss

上面分析了程序占用的 ROM 和 RAM 大小。然后分析一下数据或变量的存储位置。
<img src="https://img-blog.csdnimg.cn/e46cc5c7b3f54b44847ec4540d79798b.png" alt="在这里插入图片描述" style="zoom:67%;" />

程序编译后的内容包括：代码段（text）、数据段(data)、bss段、堆栈段（head stack） 。
其中：

- text 段：存放代码程序的可执行指令
- data 段：存放已被初始化的 全局变量 和 常量
- bss 段：存放未被初始化的 全局变量

### 2、BootLoader分析与实现

#### 1、STM32程序升级方法

##### 1.1 ST-Link / J-link下载

这个应该是最基本的方法，只要自己写过程序的应该都会，将编译生成的hex文件使用ST-Link工具或者J-Link工具直接下载进 Flash 即可。Keil中点击下载也能一键下载。

下载时可以看到地址是从0x0800 0000，即 Flash 的起始地址开始下载的。

优点：简单，插上下载器直接下载即可。
缺点：在产品中嵌入式板卡封装起来之后，因为下载口没有实际功能，所以很多时候下不拆机是没办法插上下载器的。这时候就不方便。

简单补充一句，bin文件和hex文件的区别：

- bin文件不带地址信息，因此下载的时候需要指定下载地址。
- hex文件自带地址信息，直接点击下载自己会找到要下载到的地址（默认0x0800 0000）。

##### 1.2 ISP（In System Programing）

我们常见的**一键下载电路**就是用的这种方式。这个是利用了 STM32 自带的 Bootloader 升级程序。

在用户参考手册中，可以看到下表，关于启动模式设置的。

| ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d0053b51541645ec8a3e490b84fb1d42.png) |
| ------------------------------------------------------------ |
| ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a2378a9bba5d48a28eb8ec468839e446.png) |

程序运行时的启动过程：

一般在我们的程序运行的时候，BOOT0 是接地的，也就是BOOT0 = 0。也就是程序是从主存储器Flash开始启动的，启动的地址为0x08000000。

使用ISP下载时的启动过程：

1. 首先，硬件上将 STM32 的 BOOT0 引脚拉高、BOOT1 引脚拉低，即BOOT0 = 1、BOOT1 = 0。

2. 此时，程序会从系统存储器中的程序启动，这段程序会接收串口数据（我们编译好的程序文件），并将这写数据放到主闪存存储器（Flash）当中。
3. 最后，硬件上重新将 BOOT0 接地，也就是BOOT0 = 0，然后复位引脚拉低，程序复位重启，从 Flash 中开始运行程序。

可以这么理解：芯片出厂时，系统存储器中已经存储了一段程序，这段程序的功能是将**串口1**（固定的）收到的数据，放到主闪存存储器（Flash）中，从0x0800 0000地址处开始。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9b52ef6cefc54b4991490d077bc940b0.jpeg)

ISP的下载方式：

**优点**：提供了一种升级方式，无需代码支持。
**缺点**：需要相应的硬件支持，成本增加；使用的接口也是固定的，并且很多时候串口可能用于其他功能了已经。

##### 1.3 IAP（In Applicating Programing）

IAP 和 ISP 其实基本上是一样的。

但是：ISP 是由厂商已经提供好的，因此接口固定；IAP可以自定义使用任何接口接收应用程序。也正是因为这一点，使得用户可以用多种不同的方式进行升级。

###### 1.3.1 正常程序运行流程

在看IAP之前，要先看一下正常情况下，程序从Flash启动时的启动流程，如下图所示：

1. 首先程序从Flash启动，根据中断向量表找到复位中断处理函数的地址（0x0800 0004处是中断向量表的起始地址，记录了复位中断处理函数的地址）。

2. 执行复位中断处理函数，初始化系统环境之后，该函数最后会跳转到main函数继续运行。
3. 在main函数的死循环中一直运行，直到有中断发生时（外设中断等等），重新跳转到中断向量表起始处。
4. 在中断向量表中根据中断信号源来判断要执行的中断处理函数，然后跳转到相应的中断处理函数。
5. 中断处理函数运行完成之后继续跳转到main函数处继续运行。

| ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4169eae194cc44269651d9976a76f0f9.png) |
| ------------------------------------------------------------ |

###### 1.3.2 有IAP时程序运行流程

接下来看下有了IAP之后的启动流程，如下图所示，下图中可以看到，在Flash中存储了 两“套” 程序（套的意思是，不仅只有用户程序，配套的中断向量等也都有）。

其中第一套为：Bootloader程序，该程序的功能是，接收某个接口的数据，并把这些数据存储到Flash中。

>
> 这些数据其实就是后面的**一套**APP程序，这套应用程序可以通过Bootlaoder程序保存到Flash中，这样就不用再使用专门的下载器。

第二套才是我们真正的应用程序。

1. 首先程序从Flash启动，根据中断向量表找到复位中断处理函数的地址（0x0800 0004处是中断向量表的起始地址，记录了复位中断处理函数的地址）。

2. 执行复位中断处理函数，该函数最后会跳转到Bootloader的main函数继续运行。这个main函数的任务就是，判断是否接收新的APP程序，如果有，就把新的APP程序文件保存到Flash（就是第二套程序的位置）然后跳转到第二套程序中运行。如果无，就直接跳转到第二套程序中运行。
3. 跳转之后的过程也是和正常程序运行的流程一样，一旦进入新的APP程序的起始地址，就会根据中断向量表找到复位中断处理函数，然后进入App程序的main函数运行。
4. 但是如果发生中断，是强制跳转到Bootloader程序的中断向量表进行查询的，而我们需要的肯定是需要跳转到APP程序的中断处理函数处运行。所以，在进行到APP程序后，APP程序一定要修改中断向量表的偏移，让查找对应中断处理函数的时候偏移一段地址到App程序的中断处理函数处，否则APP程序中的中断发生时，就无法跳转到APP程序的中断处理函数了。

| ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/172388cfc5c444ccb75bcde6d04e7de9.png) |
| ------------------------------------------------------------ |

对比：

|                   **ISP**                   |                           **IAP**                            |
| :-----------------------------------------: | :----------------------------------------------------------: |
| 在系统存储器中存储了一套接收串口1数据的程序 | IAP是将Flash分成了两份，在第一份中存储了一套接收某个接口的程序 |
|        使用硬件BOOT引脚设置进行跳转         |              使用软件（直接修改PC指针）进行跳转              |
|    仅能使用芯片厂商设置好的接口（串口1）    |        用户自定义，理论上只要能接收数据的接口都可以用        |

#### 2. STM32 Bootloader实现

[STM32深入系列02——BootLoader分析与实现_stm32 bootloader-CSDN博客](https://blog.csdn.net/weixin_46253745/article/details/135321134)

[STM32进阶小白教程：从boot启动到使用FreeRTOS-物联沃-IOTWORD物联网](https://www.iotword.com/18203.html)
