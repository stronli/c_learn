# 单片机项目总结

## 1、单片机中裸机系统与多任务系统

### （1）裸机系统

裸机系统通常分为轮询系统与前后台系统

#### 1）轮询系统

轮询系统即是在裸机编程的时候，先初始化好相关的硬件，然后让主程序在一个死循环里面不断循环，顺序完成各种事情，大概的伪代码具体见代码清单 4-1。轮询系统是一种非常简单的软件结构，通常只适用于那些只需要顺序执行代码且不需要外部事件来驱动就能完成的事情。在代码清单4-1中，如果只是实现LED翻转，串口输出，液晶显示等这些操作，那么适用轮询系统将会非常完美。但是，如果加入按键操作等需要检测外部信号的事件，用来模拟紧急报警，那么整个系统的实时响应能力就不会那么好了。假设DoSomething3是按键扫描，当外部按键被按下，相应于一个报警，这个时候，需要立马响应，并做紧急处理，而这个时候程序刚好执行到DoSomething1，要命的是DoSomething1需要执行的时间比较久，久到按键释放之后都没有执行完毕，那么当执行到DoSomething3的时候就会丢失掉一次事件。足见，轮询系统只适合顺序执行的功能代码，当有外部事件驱动时，实时性就会降低。

 代码清单 4-1 轮询系统伪代码

```
int main(void)
{
    /* 硬件相关初始化 */
    HardWareInit();

    /* 无限循环 */
    for(;;) {
        /* 处理事情1 */
        DoSomethin1();

        /* 处理事情2 */
        DoSomethin2();

        /* 处理事情3 */
        DoSomethin3();
    }
}
```



#### 2） 前后台系统

相比轮训系统，前后台系统是在轮系系统的基础之上加入了中断。外部事件的响应在中断里面完成，事件的处理还是回轮训系统中完成，中断在这里我们称为前台，main函数里面的无限循环我们称为后台，大概的伪代码见代码清单4-2。

```
int flag1 = 0;
int flag2 = 0;
int flag3 = 0;

int main(void)
{
    /* 硬件相关初始化 */
    HardWareInit();

    /* 无限循环 */
    for(;;) {
        if(flag1) {
            /* 处理事情1 */
            DoSomethin1();
        }
        
        if(flag2) {
            /* 处理事情2 */
            DoSomethin2();
        }

        if(flag3) {
            /* 处理事情3 */
            DoSomethin3();
        }
    }
}

void ISR1(void)
{
    /* 置位标志位 */
    flag1 = 1;

    /* 如果事件处理时间很短，则在中断里面处理
       如果事件处理事件较长，则回到后台处理   */
    DoSomethin1();
}

void ISR2(void)
{
    /* 置位标志位 */
    flag2 = 1;

    /* 如果事件处理时间很短，则在中断里面处理
       如果事件处理事件较长，则回到后台处理   */
    DoSomethin2();
}

void ISR3(void)
{
    /* 置位标志位 */
    flag3 = 1;

    /* 如果事件处理时间很短，则在中断里面处理
       如果事件处理事件较长，则回到后台处理   */
    DoSomethin3();
}
```

在顺序执行后台程序的时候，如果有中断来临，那么中断会打断后台程序的正常执行流，转而去执行中断服务程序，在中断服务程序里面标记事件，如果事件要处理的事情很简短，则可在中断服务程序里面处理，如果事件要处理的事情比较多，则返回到后台程序里面处理。虽然事件的响应和处理是分开了，但是事件的处理还是在后台里面顺序执行的，但相比轮序系统，前后台系统确保了事件不会丢失，再加上中断具有可嵌套的功能，这可以大大的提高程序的实时响应能力。在大多数中小项目中，前后台系统运用的好，堪称有操作系统的效果。

### （2）多任务系统

相比前后台系统，多任务系统的事件响应也是在中断中完成的，但是事件的处理是在任务中完成的。在多任务系统中，任务跟中断一样，也具有优先级，优先级高的任务会被优先执行。当一个紧急的事件在中断被标记后，如果事件对应的任务的优先级足够高，就会立马得到响应。相比前后台系统，多任务系统的实时性又被提高了。多任务系统大概的伪代码具体见代码清单4-3

```
int flag1 = 0;
int flag2 = 0;
int flag3 = 0;

int main(void)
{
    /* 硬件相关初始化 */
    HardWareInit();

    /* OS 初始化 */
    RTOSInit();

    /* OS 启动，开始多任务调度，不再返回 */
    RTOSStart();

}

void ISR1(void)
{
    /* 置位标志位 */
    flag1 = 1;
}

void ISR2(void)
{
    /* 置位标志位 */
    flag2 = 1;
}

void ISR3(void)
{
    /* 置位标志位 */
    flag3 = 1;
}

void DoSomethin1(void)
{
    /* 无限循环，不能返回 */
    for(;;) {
        /* 任务实体 */
        if(flag1) {

        }
    }
}

void DoSomethin2(void)
{
    /* 无限循环，不能返回 */
    for(;;) {
        /* 任务实体 */
        if(flag2) {

        }
    }
}

void DoSomethin3(void)
{
    /* 无限循环，不能返回 */
    for(;;) {
        /* 任务实体 */
        if(flag3) {

        }
    }
}
```

相比前后台系统中后台顺序执行的程序主体，在多任务系统中，根据程序的功能，我们把这个程序的主体分割成一个个独立的，无限循环且不能返回的小程序，这个小程序我们称之为任务。每个任务都是独立的，互不干扰的，且具备自身的优先级，它由操作系统调度管理。加入操作系统后，我们在编程的时候，不需要精心地去设计程序执行流，不用担心每个功能模块之间是否存在干扰。加入了操作系统，我们的编程反而变得简单了。整个系统随之带来的额外开销就是操作系统占据的那一丁点的FLASH和RAM。现如今，单片机的FLASH和RAM是越来越大，完全足以抵挡RTOS那点开销。

无论是裸机系统中的轮询系统、前后台系统和多任务系统，我们不能一锤子敲定孰优孰劣，它们是不同时代的产物，在各自的领域都还有相当大的应用价值，只有适合才是最好。有关这三者的软件模型区别具体见表格4-1。

| 模型       | 事件响应 | 事件处理 | 特点                       |
| ---------- | -------- | -------- | -------------------------- |
| 轮询系统   | 主程序   | 主程序   | 轮询响应事件，轮询处理事件 |
| 前后台系统 | 中断     | 主程序   | 实时响应事件，轮询处理事件 |
| 多任务系统 | 中断     | 任务     | 实时响应事件，实时处理事件 |

## 1、旋转试验台

H桥电路

![三极管搭建H桥电路图](https://doc.embedfire.com/motor/motor_tutorial/zh/latest/_images/H-bridge_circuit_stop.png)



1、实验目的

达到按转速和角度实现电机旋转的目的

首先定义电机状态初始化设置号驱动器ENA引脚，Dir引脚，Pul引脚

2、使用的两种方法

步进电机有一个很重要的技术参数： 空载启动频率，也就是在没有负载的情况下能够正常启动的最大脉冲频率，如果脉冲频率大于该值，步进电机则不能够正常启动， 发生丢步或者堵转的情况；**或者也可以理解为由于步进脉冲变化过快，转子由于惯性的作用跟不上电信号的变化。** 所以要使用加减速来解决启动频率低的问题，在启动时使用较低的脉冲频率，然后逐渐的加快频率。

梯形加减速实现

![梯形加减速基本数学模型](https://doc.embedfire.com/motor/motor_tutorial/zh/latest/_images/%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E6%A2%AF%E5%BD%A2%E6%A8%A1%E5%9E%8B.png)

- 在OA加速过程中，由低于步进电机的启动频率开始启动（模型中由0启动），以固定的加速度增加速度到目标值；
- 在AB匀速过程中，以最大速度匀速运动；
- 在BC减速部分中，以加速度不变的速度递减到0；

这种算法是一种在加速过程和减速过程中加速度不变的匀变速控制算法， 由于速度变化的曲线有折点，所以在启动、停止、匀速段中很容易产生冲击和振动。



抛物线实现

[机器人学之运动学笔记【6】—— 用抛物线过渡的线性插值轨迹规划方法_带抛物线过渡的线性函数规划机器人运动轨迹-CSDN博客](https://blog.csdn.net/huangjunsheng123/article/details/109407881)

```
//两个角度间的抛物线轨迹规划，应用在步进电机上
void PaoWuXian_motor_run(uint32_t dir,float Run_Time,float Begin_theta ,float Run_theta,float acceleration_buchang)
{
	int Pulse_i;
	int Pulse_Num;
	int Effictive_Pulse_time;
	int fast_angle_speed;
	int angle_speed;
	float theta_speed;
	float theta_acceleration;
	float theory_fast_speed;
	float time_b;
	float time_buchang=0;
	float t=0;
	float down_time=0;
	
	theta_acceleration = Acceleration_get(Begin_theta,Run_theta,Run_Time,acceleration_buchang);
//	boxingtushuju[0] = theta_acceleration;
	time_b = Time_d_get(theta_acceleration,Begin_theta,Run_theta,Run_Time);
//	boxingtushuju[1] = time_b;
	theory_fast_speed = theta_acceleration*time_b;
//	fast_angle_speed = theory_fast_speed*180/PAI;
//	boxingtushuju[2] = theory_fast_speed;
//	boxingtushuju[6] = fast_angle_speed;
	Pulse_Num = Run_theta*50000/360;
//	boxingtushuju[3] = Pulse_Num;
	time_buchang = (float)Run_Time/Pulse_Num;
	if(dir==1)
	{
		GPIO_SetBits(Bujin_Motor_PORT,Bujin_Motor_Dir_PIN);
	}
	if(dir==0)
	{
		GPIO_ResetBits(Bujin_Motor_PORT , Bujin_Motor_Dir_PIN);
	}
		for(Pulse_i=0;Pulse_i<=Pulse_Num;Pulse_i++)
		{
			if(t<=Run_Time-time_b)
			{//计算第一段抛物线和第二段直线的速度
				theta_speed = Paowuxain_Speed(theta_acceleration,theory_fast_speed,Run_Time,time_b,t);
			}
			else
			{//计算第三段减速抛物线的速度
				theta_speed = Paowuxian_speed_down(theta_acceleration,theory_fast_speed,down_time);
				
				down_time += time_buchang;
			}
//			angle_speed = theta_speed*180/PAI;
//			boxingtushuju[4] = angle_speed;
	    Effictive_Pulse_time = speed_to_pulsetime(theta_speed);
//			boxingtushuju[5] = Effictive_Pulse_time;
//			JustFloat_Send(boxingtushuju,7,DEBUG_USART3 );             //使用VOFA+调试时
			GPIO_SetBits(Bujin_Motor_PORT,Bujin_Motor_Pul_PIN);
		  delay_us(Effictive_Pulse_time);
		  GPIO_ResetBits(Bujin_Motor_PORT , Bujin_Motor_Pul_PIN);
		  delay_us(Effictive_Pulse_time);
			t += time_buchang;
		}
}

```



2、使用max30100和mpu6050实现

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/B6M2XPHfib1zZ48TNy1QSphadibYicibSRhqWqoRIvZibB3GuhdbuFxN8ibQo1qjjbaATeBibwjDmQ3ReyXfmc172qr2A/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 2、实时操作系统freertos

设置了四个任务分别为：

- MPU6050数据采集       优先级普通
- MAX30100数据处理     优先级普通
- MPU6050状态处理      优先级最高
- OLED刷新任务              优先级最低

```
/* Definitions for MPUHandle */
osThreadId_t MPUHandleHandle;
const osThreadAttr_t MPUHandle_attributes = {
  .name = "MPUHandle",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};

/* Definitions for MAXUsingHandler */
osThreadId_t MAXUsingHandlerHandle;
const osThreadAttr_t MAXUsingHandler_attributes = {
  .name = "MAXUsingHandler",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};

/* Definitions for MPUERRORHandler */
osThreadId_t MPUERRORHandlerHandle;
const osThreadAttr_t MPUERRORHandler_attributes = {
  .name = "MPUERRORHandler",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityHigh,
};

/* Definitions for OLEDShowHandle */
osThreadId_t OLEDShowHandleHandle;
const osThreadAttr_t OLEDShowHandle_attributes = {
  .name = "OLEDShowHandle",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityLow,
};


```

然后设置一个定时器来定时读取MAX30100代码，

```
/* Definitions for MAXDataHandle */
osTimerId_t MAXDataHandleHandle;
const osTimerAttr_t MAXDataHandle_attributes = {
  .name = "MAXDataHandle"
};
```

设置三个信号量来通知MAX30100数据处理，mpu6050异常处理，以及OLED显示

```
/* Definitions for MAXStart */
osSemaphoreId_t MAXStartHandle;
const osSemaphoreAttr_t MAXStart_attributes = {
  .name = "MAXStart"
};

/* Definitions for MPU6050Event */
osSemaphoreId_t MPU6050EventHandle;
const osSemaphoreAttr_t MPU6050Event_attributes = {
  .name = "MPU6050Event"
};

/* Definitions for OLEDShowSem */
osSemaphoreId_t OLEDShowSemHandle;
const osSemaphoreAttr_t OLEDShowSem_attributes = {
  .name = "OLEDShowSem"
};
```

添加一个事件组来标记各事件的初始状态

```
/* Definitions for TaskStaute */
osEventFlagsId_t TaskStauteHandle;
const osEventFlagsAttr_t TaskStaute_attributes = {
  .name = "TaskStaute"
};
```

开启定时器，设定定时时间为15ms

```
osStatus_t status = osTimerStart(MAXDataHandleHandle, 15);
```

然后在MPUHandleHandle中，对应的函数为MPURuning

```
MPUHandleHandle = osThreadNew(MPURuning, NULL, &MPUHandle_attributes);
```

```
float x[3];
int stepSum;
/* USER CODE END Header_MPURuning */
void MPURuning(void *argument)
{
  /* USER CODE BEGIN MPURuning */
  /* Infinite loop */
  for(;;)
  {
  //在此读取三个方向的加速度
    MPU6050_ReadAccel(&mpu6050, x, x+1, x+2);
		//printf("B:%.2f\r\n",x[2]);
		if(x[1]>1.5&&x[1]!=1.9)
		{
			stepNow = stepSum;
			//发送信号给MPU6050EventHandle
			xSemaphoreGive(MPU6050EventHandle);
		}
		if(x[1]>0.7)
		{
			stepSum++;
		}
		osDelay(10);
  }
  /* USER CODE END MPURuning */
}
```

MAX30100通过一个软件定时器，15ms采样率定时读取数据，将数据写入一个缓存区，当采集到300时，发送一个二进制信号量。

```
void MAXData(void *argument)
{
  /* USER CODE BEGIN MAXData */
		static int i = 0;
	uint32_t DCRED;
	update();
	DCRED = -removeRedDcComponent(rawIRValue)*2;
	Data[i++] = DCRED;
	if(i==300)
	{
		xSemaphoreGive(MAXStartHandle);
		i = 0;
	}
  /* USER CODE END MAXData */
}
```

![image-20240429191907944](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240429191907944.png)

### 1、freertos

```
osThreadId_t defaultTaskHandle;
const osThreadAttr_t defaultTask_attributes = {
  .name = "defaultTask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};

```

- osThreadId_t defaultTaskHandle;: 这是用来存储默认任务的线程句柄（handle），它可以用来控制和管理该任务。

- const osThreadAttr_t defaultTask_attributes = { ... };: 这是默认任务的属性配置，使用了 osThreadAttr_t 结构体。下面是这些属性的含义：

- .name = "defaultTask": 默认任务的名称，方便在代码中识别和调试。

- .stack_size = 128 * 4: 默认任务的堆栈大小，以字节为单位。这里堆栈大小为128 * 4字节，实际大小取决于实际需求和RTOS的要求。

- .priority = (osPriority_t) osPriorityNormal: 默认任务的优先级。在这里，优先级设置为正常优先级，具体优先级值可能会根据RTOS的不同而有所不同。

```
defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
```

- `StartDefaultTask`: 这是要作为默认任务执行的函数名。在这里，任务函数被命名为 `StartDefaultTask`。
- `NULL`: 这个参数是传递给任务函数的参数指针。在这里，没有传递任何参数给任务函数，所以使用了 `NULL`。
- `&defaultTask_attributes`: 这是一个指向 `defaultTask_attributes` 结构体的指针，它包含了默认任务的属性配置，如任务名称、堆栈大小和优先级等信息。

```
void StartDefaultTask(void *argument)
{
  /* USER CODE BEGIN StartDefaultTask */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
  }
  /* USER CODE END StartDefaultTask */
}
```

FreeRTOS 中任务的优先级是通过枚举类型 `osPriority_t` 来表示的，其优先级范围是从最低优先级 `osPriorityIdle` 到最高优先级 `osPriorityRealtime`。这些优先级按照数值从低到高的顺序依次排列，具体如下：

- `osPriorityIdle`: 空闲优先级，用于空闲任务。
- `osPriorityLow`: 低优先级。
- `osPriorityLow1`、`osPriorityLow2`、...、`osPriorityLow7`: 低优先级的具体级别，数值越大优先级越高。
- `osPriorityNormal`: 正常优先级。
- `osPriorityNormal1`、`osPriorityNormal2`、...、`osPriorityNormal7`: 正常优先级的具体级别，数值越大优先级越高。
- `osPriorityHigh`: 高优先级。
- `osPriorityHigh1`、`osPriorityHigh2`、...、`osPriorityHigh7`: 高优先级的具体级别，数值越大优先级越高。
- `osPriorityRealtime`: 实时优先级，最高优先级。

### 2、pagestack.c

```
#include "PageStack.h"

uint8_t user_Stack_Push(user_Stack_T* stack, StackData_t datain)
{
  if(stack->Top_Point == MAX_DEPTH - 1)
	{return -1;}
	
	stack->Data[stack->Top_Point++] = datain;
	return 0;
}

uint8_t user_Stack_Pop(user_Stack_T* stack)
{
  if(stack->Top_Point == 0)
	{return -1;}
	
	stack->Data[--stack->Top_Point] = NULL;
	return 0;
}

uint8_t user_Stack_isEmpty(user_Stack_T* stack)
{
	if(stack->Top_Point == 0)
	{return 1;} 

	return 0;
}

void user_Stack_Clear(user_Stack_T* stack)
{
	while(!user_Stack_isEmpty(stack))
	{
		user_Stack_Pop(stack);
	}
}
```

实现了基本的入栈、出栈

### 3、StrCalculate.c

使用栈实现计算器功能

### 4、在watch中使用的rtos功能

#### 4.1 user_TaskInit.c

开启一个定时器

```
/* Timers --------------------------------------------------------------------*/
osTimerId_t IdleTimerHandle;
```

创建LVGL任务

```
osThreadId_t LvHandlerTaskHandle;
const osThreadAttr_t LvHandlerTask_attributes = {
  .name = "LvHandlerTask",
  .stack_size = 128 * 24,
  .priority = (osPriority_t) osPriorityLow,
};
```

创建看门狗任务

```
//WDOG Feed task
osThreadId_t WDOGFeedTaskHandle;
const osThreadAttr_t WDOGFeedTask_attributes = {
  .name = "WDOGFeedTask",
  .stack_size = 128 * 1,
  .priority = (osPriority_t) osPriorityHigh2,
};
```

然后是创建一系列的任务

创建消息队列

```
osMessageQueueId_t Key_MessageQueue;
osMessageQueueId_t Idle_MessageQueue;
osMessageQueueId_t Stop_MessageQueue;
osMessageQueueId_t IdleBreak_MessageQueue;
osMessageQueueId_t HomeUpdata_MessageQueue;
osMessageQueueId_t DataSave_MessageQueue;
```

#### 4.2 user_ChargPageTask.c

```
void ChargPageEnterTask(void *argument)
{
	while(1)
	{
		if(HardInt_Charg_flag)
		{
			IdleTimerCount = 0;
			HardInt_Charg_flag = 0;
			if((ChargeCheck()) && (ScrRenewStack.Data[ScrRenewStack.Top_Point-1] != (long long int)&ui_ChargPage))
			{
				ui_ChargPage_screen_init();
				lv_scr_load_anim(ui_ChargPage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
				user_Stack_Push(&ScrRenewStack,(long long int)&ui_ChargPage);
			}
			else if((!ChargeCheck()) && (ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_ChargPage))
			{
				ui_HomePage_screen_init();
				lv_scr_load_anim(ui_HomePage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
				user_Stack_Pop(&ScrRenewStack);
				user_Stack_Push(&ScrRenewStack,(long long int)&ui_HomePage);
			}
		}
		osDelay(500);
	}
}
```

这段代码是一个任务函数 `ChargPageEnterTask`，它通过循环一直在运行。

在循环中，首先检查 `HardInt_Charg_flag` 是否被设置。如果被设置了，表示有硬件中断发生。在这种情况下，首先将 `IdleTimerCount` 设置为0，然后将 `HardInt_Charg_flag` 清零，表示处理了硬件中断。

接着，它检查是否需要进入充电页面或者返回主页面。具体逻辑如下：

- 如果充电状态检测为真 (`ChargeCheck()`)，且当前页面不是充电页面，则初始化充电页面，并将其加载到屏幕上，并将充电页面的地址推入页面刷新栈中。
- 如果充电状态检测为假，且当前页面是充电页面，则初始化主页面，并将其加载到屏幕上，然后将充电页面的地址从页面刷新栈中弹出，并将主页面的地址推入页面刷新栈中。

最后，任务调用 `osDelay(500)` 函数来让出处理器，使得任务每隔500毫秒执行一次循环。

这个任务的作用是根据充电状态切换显示页面，并且通过检查硬件中断标志位来触发相应的操作。

```
void ChargPageRenewTask(void *argument)
{
	while(1)
	{
		if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_ChargPage)
		{
			uint8_t value_strbuf[5];
			RTC_DateTypeDef nowdate;
			RTC_TimeTypeDef nowtime;
			
			HAL_RTC_GetTime(&hrtc,&nowtime,RTC_FORMAT_BIN);//
			HAL_RTC_GetDate(&hrtc,&nowdate,RTC_FORMAT_BIN);
			
			if(ui_TimeMinuteValue != nowtime.Minutes)
			{
				ui_TimeMinuteValue = nowtime.Minutes;
				sprintf(value_strbuf,"%02d",ui_TimeMinuteValue);
				lv_label_set_text(ui_ChargPagebMinLabel, value_strbuf);
			}
			
			if(ui_TimeHourValue != nowtime.Hours)
			{
				ui_TimeHourValue = nowtime.Hours;
				sprintf(value_strbuf,"%02d",ui_TimeHourValue);
				lv_label_set_text(ui_ChargPagebHourLabel, value_strbuf);
			}
			
			ui_BatArcValue = PowerCalculate();
			if(ui_BatArcValue>0 && ui_BatArcValue<=100)
			{
				lv_arc_set_value(ui_CharPageBatArc, ui_BatArcValue);
				sprintf(value_strbuf,"%2d%%",ui_BatArcValue);
				lv_label_set_text(ui_ChargPageBatNum, value_strbuf);
			}
			else
			{ui_BatArcValue=0;}
			
		}
		osDelay(2000);
	}
}
```

这段代码是另一个任务函数 `ChargPageRenewTask`，它也是一个无限循环的任务。

在循环中，首先检查当前页面是否是充电页面。如果是充电页面，则执行以下操作：

- 获取当前的RTC日期和时间。
- 检查分钟数是否有变化，如果有变化则更新分钟数的显示。
- 检查小时数是否有变化，如果有变化则更新小时数的显示。
- 获取电池剩余容量，并更新电池电量百分比的显示。
- 如果电池剩余容量在有效范围内（0到100之间），则更新电池电量的弧形显示和数字显示；否则将电池电量设置为0。

最后，任务调用 `osDelay(2000)` 函数来让出处理器，使得任务每隔2秒执行一次循环。

这个任务的作用是实时更新充电页面上的时间和电池电量显示。

#### 4.3 use_HomePageTask.c

```
void TimeRenewTask(void *argument)
{
	uint8_t value_strbuf[10];
	while(1)
	{
		if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_HomePage)
		{
			/*
			lv_obj_set_style_text_opa(ui_TimeColonLabel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
			osDelay(500);
			lv_obj_set_style_text_opa(ui_TimeColonLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
			*/
			
			//time get and renew the screen
			RTC_DateTypeDef nowdate;
			RTC_TimeTypeDef nowtime;
			
			HAL_RTC_GetTime(&hrtc,&nowtime,RTC_FORMAT_BIN);//要先gettime,否则更新不了时间
			HAL_RTC_GetDate(&hrtc,&nowdate,RTC_FORMAT_BIN);
			
			if(ui_TimeMinuteValue != nowtime.Minutes)
			{
				ui_TimeMinuteValue = nowtime.Minutes;
				sprintf(value_strbuf,"%02d",ui_TimeMinuteValue);
				lv_label_set_text(ui_TimeMinuteLabel, value_strbuf);
			}
			
			if(ui_TimeHourValue != nowtime.Hours)
			{
				ui_TimeHourValue = nowtime.Hours;
				sprintf(value_strbuf,"%2d",ui_TimeHourValue);
				lv_label_set_text(ui_TimeHourLabel, value_strbuf);
			}
			
			if(ui_DateDayValue != nowdate.Date)
			{
				ui_DateDayValue = nowdate.Date;
				ui_DataWeekdayValue = nowdate.WeekDay;
				sprintf(value_strbuf,"%2d-%02d",ui_DateMonthValue,ui_DateDayValue);
				lv_label_set_text(ui_DateLabel, value_strbuf);
				lv_label_set_text(ui_DayLabel, ui_Days[ui_DataWeekdayValue-1]);
				
			}
			if(ui_DateMonthValue != nowdate.Month)
			{
				ui_DateMonthValue = nowdate.Month;
				ui_DateDayValue = nowdate.Date;
				ui_DataWeekdayValue = nowdate.WeekDay;
				sprintf(value_strbuf,"%2d-%02d",ui_DateMonthValue,ui_DateDayValue);
				lv_label_set_text(ui_DateLabel, value_strbuf);
				lv_label_set_text(ui_DayLabel, ui_Days[ui_DataWeekdayValue-1]);
			}
		}
		osDelay(500);
	}
}
```

在循环中，首先检查当前页面是否是主页（`ui_HomePage`），如果是主页，则执行以下操作：

- 获取当前的RTC日期和时间。
- 检查分钟数是否有变化，如果有变化则更新分钟数的显示。
- 检查小时数是否有变化，如果有变化则更新小时数的显示。
- 检查日期是否有变化，如果有变化则更新日期和星期的显示。

在更新日期时，代码先检查日期是否有变化，如果有变化则更新日期和星期的显示；然后再检查月份是否有变化，如果有变化则更新日期和星期的显示。

最后，任务调用 `osDelay(500)` 函数来让出处理器，使得任务每隔500毫秒执行一次循环。

这个任务的作用是实时更新主页上的时间、日期和星期显示

```
void HomeUpdata_Task(void *argument)
{
	while(1)
	{
		uint8_t HomeUpdataStr;
		if(osMessageQueueGet(HomeUpdata_MessageQueue,&HomeUpdataStr,NULL,0)==osOK)
		{
			//bat
			uint8_t value_strbuf[5];
			
			ui_BatArcValue = PowerCalculate();
			if(ui_BatArcValue>0 && ui_BatArcValue<=100)
			{}
			else
			{ui_BatArcValue=0;}
			
			//steps
			if(!Sensor_MPU_Erro)
			{
				unsigned long	STEPS = 0;
				if(!Sensor_MPU_Erro)
					dmp_get_pedometer_step_count(&STEPS);
				ui_StepNumValue = (uint16_t)STEPS;
			}
			
			//temp and humi
			if(!Sensor_AHT21_Erro)
			{
				//temp and humi messure
				float humi,temp;
				AHT_Read(&humi,&temp);
				//check
				if(temp>-10 && temp<50 && humi>0 && humi<100)
				{
					ui_EnvTempValue = (int8_t)temp;
					ui_EnvHumiValue = (int8_t)humi;
				}
			}
			
			//set text
			if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_HomePage)
			{
				//bat set text
				lv_arc_set_value(ui_BatArc, ui_BatArcValue);
				sprintf(value_strbuf,"%2d%%",ui_BatArcValue);
				lv_label_set_text(ui_BatNumLabel, value_strbuf);
				
				//step set text
				sprintf(value_strbuf,"%d",ui_StepNumValue);
				lv_label_set_text(ui_StepNumLabel, value_strbuf);
				
				//send data save message queue
				uint8_t Datastr = 3;
				osMessageQueuePut(DataSave_MessageQueue, &Datastr, 0, 1);
				
				//humi and temp set text
				lv_arc_set_value(ui_TempArc, ui_EnvTempValue);
				lv_arc_set_value(ui_HumiArc, ui_EnvHumiValue);
				sprintf(value_strbuf,"%d",ui_EnvTempValue);
				lv_label_set_text(ui_TempNumLabel, value_strbuf);
				sprintf(value_strbuf,"%d",ui_EnvHumiValue);
				lv_label_set_text(ui_HumiNumLabel, value_strbuf);
				
			}
			
		}
		osDelay(500);
	}
}
```

这段代码实现了一个任务 `HomeUpdata_Task`，用于更新主页上显示的数据，包括电池电量、步数、温湿度等。在这个任务中，主要执行以下操作：

1. **接收消息队列数据**：

   - 使用 `osMessageQueueGet` 检查消息队列 `HomeUpdata_MessageQueue` 中是否有新消息。如果有新消息，则进入更新逻辑。

2. **电池电量**：

   - 调用 `PowerCalculate()` 函数获取电池电量值，并确保该值在 0 到 100 之间。如果不在这个范围内，则将其设置为 0。

3. **步数**：

   - 如果传感器 MPU 正常工作，调用 `dmp_get_pedometer_step_count` 获取当前步数，并将其存储到 `ui_StepNumValue`。

4. **温湿度**：

   - 如果 AHT21 传感器没有错误，调用 `AHT_Read` 读取温度和湿度数据。数据范围检查确保温度在 -10 到 50 之间，湿度在 0 到 100 之间。合格的数据被存储到 `ui_EnvTempValue` 和 `ui_EnvHumiValue`。

5. **更新主页显示**：

   - 如果当前页面是

     ```
      ui_HomePage
     ```
     
     ，更新相关数据显示：

     - 使用 `lv_arc_set_value` 更新电池电量、温度、湿度等进度条的显示。
  - 使用 `lv_label_set_text` 更新电池电量、步数、温度、湿度等标签的文本。
    
   - 向 `DataSave_MessageQueue` 发送消息 `Datastr = 3` 表示数据已更新并可能需要保存。

6. **循环与延时**：

   - 任务最后调用 `osDelay(500)` 以每 500 毫秒进行一次循环。

这个任务的主要功能是确保主页上的显示数据是实时的，同时通过消息队列机制与其他任务/模块进行通信，从而保持系统的一致性。

#### 4.4 user_MessageSendTask.c

```
void MessageSendTask(void *argument)
{
	while(1)
	{
		if(HardInt_uart_flag)
		{
			HardInt_uart_flag = 0;
			uint8_t IdleBreakstr=0;
			osMessageQueuePut(IdleBreak_MessageQueue,&IdleBreakstr,NULL,1);
			printf("RecStr:%s\r\n",HardInt_receive_str);
			if(!strcmp(HardInt_receive_str,"OV"))
			{
				printf("OK\r\n");
			}
			else if(!strcmp(HardInt_receive_str,"OV+VERSION"))
			{
				printf("VERSION=V2.3\r\n");
			}
			else if(!strcmp(HardInt_receive_str,"OV+SEND"))
			{
				HAL_RTC_GetTime(&hrtc,&(BLEMessage.nowtime),RTC_FORMAT_BIN);
				HAL_RTC_GetDate(&hrtc,&BLEMessage.nowdate,RTC_FORMAT_BIN);
				BLEMessage.humi = ui_EnvHumiValue;
				BLEMessage.temp = ui_EnvTempValue;
				BLEMessage.HR = ui_HRValue;
				BLEMessage.SPO2 = ui_SPO2Value;
				BLEMessage.stepNum = ui_StepNumValue;

				printf("data:%2d-%02d\r\n",BLEMessage.nowdate.Month,BLEMessage.nowdate.Date);
				printf("time:%02d:%02d:%02d\r\n",BLEMessage.nowtime.Hours,BLEMessage.nowtime.Minutes,BLEMessage.nowtime.Seconds);
				printf("humidity:%d%%\r\n",BLEMessage.humi);
				printf("temperature:%d\r\n",BLEMessage.temp);
				printf("Heart Rate:%d%%\r\n",BLEMessage.HR);
				printf("SPO2:%d%%\r\n",BLEMessage.SPO2);
				printf("Step today:%d\r\n",BLEMessage.stepNum);
			}
			//set time//OV+ST=20230629125555
			else if(strlen(HardInt_receive_str)==20)
			{
				uint8_t cmd[10];
				memset(cmd,0,sizeof(cmd));
				StrCMD_Get(HardInt_receive_str,cmd);
				if(user_APPSy_EN && !strcmp(cmd,"OV+ST"))
				{
					TimeFormat_Get(HardInt_receive_str);
				}
			}
			memset(HardInt_receive_str,0,sizeof(HardInt_receive_str));
		}
		osDelay(1000);
	}
}
```

本函数是通过串口给蓝牙发送信息

1. 进入一个无限循环 (`while(1)`)，持续执行任务。
2. 检查 `HardInt_uart_flag` 标志位，如果为真，则表示收到了 UART 中断，并且有数据需要处理。
3. 将 `HardInt_uart_flag` 置零，表示已经处理了 UART 中断。
4. 根据接收到的消息进行不同的操作：
   - 如果接收到的消息是 "OV"，则打印 "OK"。
   - 如果接收到的消息是 "OV+VERSION"，则打印 "VERSION=V2.3"。
   - 如果接收到的消息是 "OV+SEND"，则获取当前环境参数（湿度、温度、心率、血氧、步数等）并打印。
   - 如果接收到的消息长度为 20，并且以 "OV+ST" 开头，则将接收到的时间信息格式化，并设置系统时间。
5. 清空接收缓冲区 `HardInt_receive_str`。
6. 在每次循环结束时延时 1000 毫秒（1 秒）。

#### 4.5 user_MPUCheckTask.c

```
void MPUCheckTask(void *argument)
{
	while(1)
	{
		if(user_MPU_Wrist_EN)
		{
			if(MPU_isHorizontal())
			{
				user_MPU_Wrist_State = WRIST_UP;
			}
			else
			{
				if(user_MPU_Wrist_State == WRIST_UP)
				{
					user_MPU_Wrist_State = WRIST_DOWN;
					if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_HomePage || 
						ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_MenuPage ||
						ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_SetPage)
					{
						uint8_t Stopstr;
						osMessageQueuePut(Stop_MessageQueue, &Stopstr, 0, 1);//sleep
					}
				}
				user_MPU_Wrist_State = WRIST_DOWN;
			}
		}
		osDelay(300);
	}
}
```



1. 进入一个无限循环 (`while(1)`)，持续执行任务。

2. 检查 `user_MPU_Wrist_EN` 变量，如果为真（表示用户允许使用 MPU 检测手腕状态）。

3. 调用 `MPU_isHorizontal()` 函数来检测手腕的水平状态：

   - 如果手腕是水平的（即处于平放状态），则将 `user_MPU_Wrist_State` 设置为 `WRIST_UP`。

   - 否则，如果手腕不是水平的，首先检查

     ```
     user_MPU_Wrist_State
     ```

     的状态是否为

     ```
     WRIST_UP
     ```

     - 如果是 `WRIST_UP`，则将 `user_MPU_Wrist_State` 设置为 `WRIST_DOWN`。
     - 接着检查当前显示屏的页面是否为主页、菜单页或设置页，如果是，则向 `Stop_MessageQueue` 消息队列发送一个 `Stopstr` 数据，用于暂停相应的任务（通过 `osMessageQueuePut` 函数）。

4. 如果手腕不是水平的，无论之前的状态如何，最终都将 `user_MPU_Wrist_State` 设置为 `WRIST_DOWN`。

5. 在每次循环结束时使用 `osDelay(300)` 函数进行延时，延时 300 毫秒（即 0.3 秒）。

#### 4.6 user_ScrRenewTask.c

```
void ScrRenewTask(void *argument)
{
	uint8_t keystr=0;
	user_Stack_Push(&ScrRenewStack,(long long int)&ui_HomePage);
	while(1)
	{
		if(osMessageQueueGet(Key_MessageQueue,&keystr,NULL,0)==osOK)
		{
			//key1 pressed
			if(keystr == 1)
			{
				user_Stack_Pop(&ScrRenewStack);
				if(user_Stack_isEmpty(&ScrRenewStack))
				{
					ui_MenuPage_screen_init();
					lv_scr_load_anim(ui_MenuPage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
					user_Stack_Push(&ScrRenewStack,(long long int)&ui_HomePage);
					user_Stack_Push(&ScrRenewStack,(long long int)&ui_MenuPage);
				}
				else if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_HomePage)
				{
					ui_HomePage_screen_init();
					lv_scr_load_anim(ui_HomePage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
				}
				else if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_MenuPage)
				{
					ui_MenuPage_screen_init();
					lv_scr_load_anim(ui_MenuPage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
					//HR sensor sleep
    			EM7028_hrs_DisEnable();
    			//sensor sleep
		    	LSM303DLH_Sleep();
					//SPL_Sleep();
				}
				else if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_GameSelectPage)
				{
					ui_GameSelectPage_screen_init();
					lv_scr_load_anim(ui_GameSelectPage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
				}
				else if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_SetPage)
				{
					ui_SetPage_screen_init();
					lv_scr_load_anim(ui_SetPage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
				}
				else if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_DateTimeSetPage)
				{
					ui_DateTimeSetPage_screen_init();
					lv_scr_load_anim(ui_DateTimeSetPage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
				}
				
			}	
			//key2 pressed
			else if(keystr == 2)
			{
				user_Stack_Clear(&ScrRenewStack);
				ui_HomePage_screen_init();
				lv_scr_load_anim(ui_HomePage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);
				user_Stack_Push(&ScrRenewStack,(long long int)&ui_HomePage);
				//HR sensor sleep
  			EM7028_hrs_DisEnable();
  			//sensor sleep
	    	LSM303DLH_Sleep();
				//SPL_Sleep();
			}
		}	
		osDelay(10);
	}
}

```

- 首先，将主页界面的地址压入栈中。
- 进入一个无限循环，不断检测按键消息队列中是否有按键消息。
- 如果检测到按键消息，根据按键的值进行不同的处理：
  - 如果是按键1被按下，根据当前栈顶元素的不同，执行不同的操作：
    - 如果当前界面是主页，则重新初始化主页并加载主页界面。
    - 如果当前界面是菜单页，则重新初始化菜单页并加载菜单页界面，同时关闭心率传感器和其他传感器。
    - 如果当前界面是游戏选择页，则重新初始化游戏选择页并加载游戏选择页界面。
    - 如果当前界面是设置页，则重新初始化设置页并加载设置页界面。
    - 如果当前界面是日期时间设置页，则重新初始化日期时间设置页并加载日期时间设置页界面。
  - 如果是按键2被按下，清空栈并重新初始化主页，并加载主页界面，同时关闭心率传感器和其他传感器。
- 最后，延时10毫秒，等待下一次检测。

#### 4.7 user_SensorPageTask.c

```
void HRDataRenewTask(void *argument)
{
	uint8_t value_strbuf[4];
	uint8_t IdleBreakstr=0;
	uint16_t dat=0;
	uint8_t hr_temp=0;
	while(1)
	{
		if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_HRPage)
		{
			osMessageQueuePut(IdleBreak_MessageQueue, &IdleBreakstr, 0, 1);
			//sensor wake up
			EM7028_hrs_Enable();
			//receive the sensor wakeup message, sensor wakeup
			if(!Sensor_EM_Erro)
			{
				//Hr messure
				vTaskSuspendAll();
				hr_temp = HR_Calculate(EM7028_Get_HRS1(),user_HR_timecount);
				xTaskResumeAll();
				if(ui_HRValue != hr_temp && hr_temp>50 && hr_temp<120)
				{
					//set text
					ui_HRValue = hr_temp;
					sprintf(value_strbuf, "%d", ui_HRValue);
					lv_label_set_text(ui_HRPageNumLabel, value_strbuf);
				}
			}
		}
		osDelay(50);
	}
}
```

1. 任务在一个 while 循环中持续运行。
2. 它检查堆栈（`ScrRenewStack`）的顶部元素是否指向心率页面（`ui_HRPage`）。
3. 如果条件满足，它将一个消息放入空闲中断消息队列（`IdleBreak_MessageQueue`）以唤醒传感器。
4. 它启用心率传感器（`EM7028_hrs_Enable()`）。
5. 如果从 EM 传感器没有错误（`!Sensor_EM_Erro`），则使用 `HR_Calculate()` 函数计算心率，然后更新 UI 显示新的心率值。
6. 任务然后延迟 50 毫秒后再次循环。

```
void SensorDataRenewTask(void *argument)
{
	uint8_t value_strbuf[6];
	uint8_t IdleBreakstr=0;
	while(1)
	{
		if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_SPO2Page)
		{
			osMessageQueuePut(IdleBreak_MessageQueue, &IdleBreakstr, 0, 1);
			//sensor wake up
			
			//receive the sensor wakeup message, sensor wakeup
			if(0)
			{
				//SPO2 messure

				//set text
				sprintf(value_strbuf, "%d", ui_SPO2Value);
				lv_label_set_text(ui_SPO2NumLabel, value_strbuf);
			}
		}

这段代码片段中的条件语句判断当前显示的页面是否为血氧页面（ui_SPO2Page）。如果是血氧页面，会将一个消息放入消息队列中，表示空闲状态中断（IdleBreak）。然后，它会尝试唤醒传感器（这里的代码可能被注释掉了）。接着，代码中有一个条件判断 if(0)，这个条件始终为假，所以它下面的血氧测量和文本设置部分永远不会执行。因此，这部分代码实际上没有对血氧数据进行任何操作。
		else if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_EnvPage)
		{
			osMessageQueuePut(IdleBreak_MessageQueue, &IdleBreakstr, 0, 1);
			//receive the sensor wakeup message, sensor wakeup
			if(!Sensor_AHT21_Erro)
			{
				//temp and humi messure
				float humi,temp;
				AHT_Read(&humi,&temp);
				//check
				if(temp>-10 && temp<50 && humi>0 && humi<100)
				{
					ui_EnvTempValue = (int8_t)temp;
					ui_EnvHumiValue = (int8_t)humi;
				}
				//set text
				lv_bar_set_value(ui_EnvTempBar, ui_EnvTempValue, LV_ANIM_OFF);
				lv_bar_set_value(ui_EnvHumiBar, ui_EnvHumiValue, LV_ANIM_OFF);
				sprintf(value_strbuf,"%d",ui_EnvTempValue);
				lv_label_set_text(ui_EnvTempNumLabel, value_strbuf);
				sprintf(value_strbuf,"%d",ui_EnvHumiValue);
				lv_label_set_text(ui_EnvHumiNumLabel, value_strbuf);
			}

		}
		这段代码是针对环境页面（ui_EnvPage）的逻辑。首先，它也会向消息队列中放入一个消息，表示空闲状态中断（IdleBreak）。然后，它会尝试唤醒传感器（这里的代码也可能被注释掉了）。接着，它会检查传感器是否出错（Sensor_AHT21_Erro），如果没有出错，就会进行温度和湿度的测量（AHT_Read(&humi,&temp)）。然后会检查测得的温度和湿度是否在合理的范围内，如果是的话，就会更新环境温度和湿度的数值，并更新相应的显示条（lv_bar_set_value）和文本标签（lv_label_set_text）。最后，通过sprintf函数将温度和湿度的数值转换为字符串，并设置到相应的文本标签上。
		else if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&ui_CompassPage)
		{
			osMessageQueuePut(IdleBreak_MessageQueue, &IdleBreakstr, 0, 1);
			//receive the sensor wakeup message, sensor wakeup
			LSM303DLH_Wakeup();
			//SPL_Wakeup();
			//if the sensor is no problem
			if(!Sensor_LSM303_Erro)
			{
				//messure
				int16_t Xa,Ya,Za,Xm,Ym,Zm;
				LSM303_ReadAcceleration(&Xa,&Ya,&Za);
				LSM303_ReadMagnetic(&Xm,&Ym,&Zm);
				float temp = Azimuth_Calculate(Xa,Ya,Za,Xm,Ym,Zm)+0;//0 offset
				if(temp<0)
				{temp+=360;}
				//check
				if(temp>=0 && temp<=360)
				{
					ui_CompassDirValue = (uint16_t)temp;
				}
				//set text
				lv_img_set_angle(ui_Compassneedle, ui_CompassDirValue*10);
				sprintf(value_strbuf,":%d", ui_CompassDirValue);
				lv_label_set_text(ui_CompassDirLabel, value_strbuf);
			}
			这段代码处理指南针页面（ui_CompassPage）的逻辑。首先，它也会向消息队列中放入一个消息，表示空闲状态中断（IdleBreak）。然后，它会唤醒传感器（LSM303DLH_Wakeup()）。接着，它会检查传感器是否出错（Sensor_LSM303_Erro），如果没有出错，就会进行加速度和磁场的测量（LSM303_ReadAcceleration和LSM303_ReadMagnetic），然后通过这些数据计算出方位角（Azimuth_Calculate），并进行一些处理，如添加偏移量。接着，它会检查计算得到的方位角是否在合理的范围内，如果是的话，就会更新指南针方向的数值，并设置相应的显示图像（lv_img_set_angle）和文本标签（lv_label_set_text）。
[好像出错了，请稍后再试。
			//if the sensor is no problem
			if(!Sensor_SPL_Erro)
			{
				//messure
				float alti = Altitude_Calculate();
				//check
				if(1)
				{
					ui_EnvAltitudeValue = (int16_t)alti;
				}
				//set text
				sprintf(value_strbuf,":%dm", ui_EnvAltitudeValue);
				lv_label_set_text(ui_EnvAltitudeLabel, value_strbuf);
			}
		}
		
		osDelay(300);
	}
}
这段代码是针对环境页面中海拔（altitude）数据的逻辑。首先，它检查传感器是否出错（Sensor_SPL_Erro），如果没有出错，就会进行海拔的测量（Altitude_Calculate()）。然后，它会检查是否要进行进一步的处理（这里的条件始终为真）。接着，如果满足条件，就会更新环境海拔的数值，并将其转换为字符串格式（以米为单位），最后设置到相应的文本标签上。最后，通过osDelay函数让线程延迟300毫秒，以降低处理器负载。
```

#### 4.8 user_StopEnterTask.c

```
void IdleEnterTask(void *argument)
{
	uint8_t Idlestr=0;
	uint8_t IdleBreakstr=0;
	while(1)
	{
		//light get dark
		if(osMessageQueueGet(Idle_MessageQueue,&Idlestr,NULL,1)==osOK)
		{
			LCD_Set_Light(5);
		}
		//resume light if light got dark and idle state breaked by key pressing or screen touching
		if(osMessageQueueGet(IdleBreak_MessageQueue,&IdleBreakstr,NULL,1)==osOK)
		{
			IdleTimerCount = 0;
			LCD_Set_Light(ui_LightSliderValue);
		}
		osDelay(10);
	}
}
```

本代码定义了一个IdleEnterTask的任务函数。会不断检查消息队列中的消息，首先它检查Idle_MessageQueue消息队列是否有消息，如果有，就表示光线变暗，于是调用LCD_Set_Light函数将屏幕亮度设置为5。然后，它检查IdleBreak_MessageQueue消息队列是否有消息，如果有，就表示空闲状态被打破（可能是通过按键或触摸屏），于是将IdleTimerCount计数器归零，并将屏幕亮度恢复为之前的值（ui_LightSliderValue）。最后，通过osDelay函数让线程延迟10毫秒，以降低处理器负载。

```
void IdleTimerCallback(void *argument)
{
	IdleTimerCount+=1;
	//make sure the LightOffTime<TurnOffTime
	if(IdleTimerCount == (ui_LTimeValue*10))
	{
		uint8_t Idlestr=0;
		//send the Light off message
		osMessageQueuePut(Idle_MessageQueue, &Idlestr, 0, 1);
		
	}
	if(IdleTimerCount == (ui_TTimeValue*10))
	{
		uint8_t Stopstr = 1;
		IdleTimerCount  = 0;
		//send the Stop message
		osMessageQueuePut(Stop_MessageQueue, &Stopstr, 0, 1);
	}
}
```

这段代码看起来是用于嵌入式系统中的低功耗管理。主要包含了进入停止模式和恢复运行模式的任务函数 `StopEnterTask`，以及空闲计时器的回调函数 `IdleTimerCallback`。

在 `StopEnterTask` 中，当接收到 `Stop_MessageQueue` 的消息时，执行一系列睡眠操作，然后暂停所有 FreeRTOS 任务，进入停止模式。在退出停止模式后，恢复运行模式，执行相应的唤醒操作。

而 `IdleTimerCallback` 则用于管理空闲计时器，在达到一定时间后发送相应的消息，包括关闭 LCD 屏幕和进入停止模式的消息。

整体来看，这段代码实现了低功耗管理，通过在空闲状态下进入停止模式来节省能源。

```
void StopEnterTask(void *argument)
{
	uint8_t Stopstr;
	uint8_t HomeUpdataStr;
	uint8_t Wrist_Flag=0;
	while(1)
	{
		if(osMessageQueueGet(Stop_MessageQueue,&Stopstr,NULL,0)==osOK)
		{
			
			/***** your sleep operations *****/
			sleep:
			IdleTimerCount = 0;

			//sensors
			
			//lcd
			LCD_RES_Clr();
			LCD_Close_Light();
			//touch
			CST816_Sleep();
			
			/*********************************/
			
			vTaskSuspendAll();
			//Disnable Watch Dog
			WDOG_Disnable();
			//systick int
			CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
			//enter stop mode
			HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON,PWR_STOPENTRY_WFI);
			
			//here is the sleep period

			//resume run mode and reset the sysclk
			SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
			HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq));
			SystemClock_Config();
			WDOG_Feed();
			xTaskResumeAll();
			
			/***** your wakeup operations *****/
			
			//MPU Check
			if(user_MPU_Wrist_EN)
			{
				uint8_t hor;
				hor = MPU_isHorizontal();
				if(hor && user_MPU_Wrist_State == WRIST_DOWN)
				{
					user_MPU_Wrist_State = WRIST_UP;
					Wrist_Flag = 1;
					//resume, go on
				}
				else if(!hor && user_MPU_Wrist_State == WRIST_UP)
				{
					user_MPU_Wrist_State = WRIST_DOWN;
					IdleTimerCount  = 0;
					goto sleep;
				}
			}
			
			//
			if(!KEY1 || KEY2 || ChargeCheck() || Wrist_Flag)
			{
				Wrist_Flag = 0;
				//resume, go on
			}
			else
			{
				IdleTimerCount  = 0;
				goto sleep;
			}
			
			
			//lcd
			LCD_Init();
			LCD_Set_Light(ui_LightSliderValue);
			//touch
			CST816_Wakeup();
			//check if is Charging
			if(ChargeCheck())
			{HardInt_Charg_flag = 1;}
			//send the Home Updata message
			osMessageQueuePut(HomeUpdata_MessageQueue, &HomeUpdataStr, 0, 1);
			/**********************************/
			
		}
		osDelay(100);
	}
}
```

这段代码定义了一个名为StopEnterTask的任务函数，用于进入停止模式并恢复。该函数也是一个无限循环，不断地检查消息队列中是否有消息。当Stop_MessageQueue消息队列中有消息时，表示需要进入停止模式。在进入停止模式之前，先执行一系列睡眠操作，包括重置空闲计时器（IdleTimerCount）、关闭LCD屏幕、关闭触摸屏等。

然后，通过vTaskSuspendAll函数暂停所有FreeRTOS任务，禁用看门狗定时器（WDOG_Disnable），关闭SysTick定时器中断，并调用HAL_PWR_EnterSTOPMode函数进入停止模式。在停止模式期间，执行一些必要的操作。

当退出停止模式时，恢复运行模式，重新设置SysTick定时器、系统时钟，并重新启用看门狗定时器。接着执行一系列唤醒操作，包括检查MPU状态、按键状态、充电状态等。最后，恢复LCD、触摸屏，检查是否正在充电，并发送HomeUpdata_MessageQueue消息。

整个过程中，通过使用goto语句，实现了在特定条件下回到睡眠状态的功能，以节省能源。

#### 4.9 user_DataSaveTask.c

```
void DataSaveTask(void *argument)
{
	
	while(1)
	{
		uint8_t Datastr=0;
		if(osMessageQueueGet(DataSave_MessageQueue,&Datastr,NULL,1)==osOK)
		{
			/****************
			Setting change
			date change
			Step change
			****************/
			uint8_t dat[3];
			dat[0] = user_MPU_Wrist_EN;
			dat[1] = user_APPSy_EN;
			SettingSave(dat,0x10,2);
			
			RTC_DateTypeDef nowdate;
			HAL_RTC_GetDate(&hrtc,&nowdate,RTC_FORMAT_BIN);
			
			SettingGet(dat,0x20,3);
			if(dat[0] != nowdate.Date)
			{
				if(!Sensor_MPU_Erro)
					dmp_set_pedometer_step_count(0);
				dat[0] = nowdate.Date;
				dat[2] = 0;
				dat[1] = 0;
				SettingSave(dat,0x20,3);
			}
			else
			{
				unsigned long	STEPS = 0;
				if(!Sensor_MPU_Erro)
					dmp_get_pedometer_step_count(&STEPS);
				uint16_t temp = (uint16_t)STEPS;
				dat[0] = nowdate.Date;
				dat[2] = temp & 0xff;
				dat[1] = temp>>8 & 0xff;
				SettingSave(dat,0x20,3);
			}
			
		}
		osDelay(100);
	}
}
```

### 5.使用的传感器硬件部分

##### 5.1 lcd.c

##### 5.2 lcd_init.c

首先进行lcd的初始化

```
void LCD_GPIO_Init(void)
{
	GPIO_InitTypeDef  GPIO_InitStructure = {0};
	
 	__HAL_RCC_GPIOB_CLK_ENABLE();
	
	GPIO_InitStructure.Pin = RES_PIN|CS_PIN|DC_PIN;	 
 	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; 		 //推挽输出
	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;//速度50MHz
 	HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);	  //初始化GPIOB
 	HAL_GPIO_WritePin(GPIOB, RES_PIN|CS_PIN|DC_PIN, GPIO_PIN_SET);
}
```

在此使用的是硬件spi

```
HAL_SPI_Transmit(&hspi1,&dat,1,1);
```

##### 5.3 power.c （充电部分设计）

使用的是3.7v锂电池进行充电，通过TPS63020提供3.3V电源

###### 5.3.1 TP4056锂电池充电芯片

TP4056是一款性能优异的单节锂离子电池恒流/恒压线性充电器。TP4056采用ESOP8封装配合较少的外围原件使其非 常适用于便携式产品，并且适合给USB电源以及适配器电源供电。

基于特殊的内部MOSFET架构以及防倒充电路，TP4056不需要外接检测电阻和隔离二极管。当外部环境温度过高或者 在大功率应用时，热反馈可以调节充电电流以降低芯片温度。充电电压固定在4.2V，而充电电流则可以通过一个电阻 器进行外部设置。当充电电流在达到最终浮充电压之后降至设定值的1/10，芯片将终止充电循环。

当输入电压断开时，TP4056进入睡眠状态，电池漏电流将降到1uA以下。TP4056可以被设置于停机模式，此时芯片 静态电流降至35uA。

TP4056还包括其他特性：电池温度监测，欠压锁定，自动再充电和两个状态引脚以显示充电和充电终止。

| ![image-20240502150413599](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502150413599.png) | ![image-20240502150459373](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502150459373.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

![image-20240502150939361](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502150939361.png)



###### 5.3.2 TPS63020升降压芯片-电池放电

在下面的电路图中可以看到

![image-20240502144648346](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502144648346.png)

63020的引脚EN为TPS_EN通过二极管连接POWER_EN，既PA3

开发板的pa1命名BAT_DET连接电池的BAT

pa2命名为CHANG,连接的是TP4056M的CHRG端，既电池充电指示端

![image-20240502145113091](C:\Users\xiaolizhi\AppData\Roaming\Typora\typora-user-images\image-20240502145113091.png)

```
#define BAT_CHECK_PORT	GPIOA
#define BAT_CHECK_PIN		GPIO_PIN_1

#define CHARGE_PORT			GPIOA
#define CHARGE_PIN			GPIO_PIN_2

#define POWER_PORT			GPIOA
#define POWER_PIN				GPIO_PIN_3
```

使用pa1为电池检测引脚，pa2为电池充电引脚，pa3为控制电源引脚

```
void Power_Pins_Init()
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(POWER_PORT, POWER_PIN, GPIO_PIN_RESET);//将POWER_PORT端口上的POWER_PIN引脚设置为低电平，从而实现关闭电源的功能。

  /*Configure GPIO pin : PA3 */
  GPIO_InitStruct.Pin = POWER_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(POWER_PORT, &GPIO_InitStruct);

  /*Configure GPIO pin : PA2 */
  GPIO_InitStruct.Pin = CHARGE_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(CHARGE_PORT, &GPIO_InitStruct);

  HAL_NVIC_SetPriority(EXTI2_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI2_IRQn);
	
}
```

在pa1上开启ADC采集，启动ADC转换，获取电池电压的原始值，然后将其转换为实际电压值并返回。

```
float BatCheck()
{
	uint16_t dat;
	float BatVoltage;
	HAL_ADC_Start(&hadc1);
	HAL_ADC_PollForConversion(&hadc1,5);
	dat = HAL_ADC_GetValue(&hadc1);
	HAL_ADC_Stop(&hadc1);
	BatVoltage = dat *2 *3.3 /4096;
	return BatVoltage;
}
```

1. `uint8_t PowerCalculate()`：这是一个返回8位无符号整数的函数，用于计算电池电量。
2. `float voltage;`：声明一个单精度浮点数变量`voltage`，用于存储电池电压值。
3. `voltage = BatCheck_8times();`：调用`BatCheck_8times()`函数获取电池电压值，并赋给`voltage`变量。
4. `if(ChargeCheck()) {voltage -= INTERNAL_RES * CHARGING_CUR;}`：如果检测到正在充电，则从电池电压中减去充电时的内阻降压。这里的`INTERNAL_RES`是内阻的值，`CHARGING_CUR`是充电时的电流值。
5. 接下来一系列的`if-else`语句根据电池电压的不同范围来确定电量的百分比：
   - 如果电压大于等于4.2V，将电量设置为100%。
   - 如果电压在4.06V到4.2V之间，将电量设置为90%。
   - 依此类推，根据不同的电压范围设置对应的电量百分比。
6. 最后，返回计算得到的电量百分比值。

这段代码通过检测电池电压并根据不同电压范围来确定电量百分比，以反映电池的实时电量情况。

```
uint8_t PowerCalculate()
{
	uint8_t power;
	float voltage;
	voltage = BatCheck_8times();
	
	if(ChargeCheck())
	{voltage -= INTERNAL_RES * CHARGING_CUR;}
	
	if((voltage >= 4.2))
	{power = 100;}
	else if(voltage >= 4.06 && voltage <4.2)
	{power = 90;}
	else if(voltage >= 3.98 && voltage <4.06)
	{power = 80;}
	else if(voltage >= 3.92 && voltage <3.98)
	{power = 70;}
	else if(voltage >= 3.87 && voltage <3.92)
	{power = 60;}
	else if(voltage >= 3.82 && voltage <3.87)
	{power = 50;}
	else if(voltage >= 3.79 && voltage <3.82)
	{power = 40;}
	else if(voltage >= 3.77 && voltage <3.79)
	{power = 30;}
	else if(voltage >= 3.74 && voltage <3.77)
	{power = 20;}
	else if(voltage >= 3.68 && voltage <3.74)
	{power = 10;}
	else if(voltage >= 3.45 && voltage <3.68)
	{power = 5;}
	return power;
}
```

### 6、平衡小车

使用直流减速电机

- 电机1——PB12/PB13
- 电机2——PB14/PB15
- PWM1——PA8
- PWM2——PA11

二、软件编程
1.电机驱动函数——motor.c
1）电机GPIO初始化函数
 入口参数：无

初始化GPIO–PB12、PB13、PB14、PB15为推挽输出

```
void Motor_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);// 开启时钟
	

	GPIO_InitStruct.GPIO_Mode=GPIO_Mode_Out_PP;// 初始化GPIO--PB12、PB13、PB14、PB15为推挽输出
	GPIO_InitStruct.GPIO_Pin=GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStruct);	

}
```

2）限幅函数
 入口参数：电机A脉冲个数，电机B脉冲个数

限制电机的脉冲个数在规定范围内，有个最值，即自动重装载值（我设置的是PWM_MAX = 7200，PWM_MIN = -7200）

```
void Limit(int *motoA,int *motoB)
{
	if(*motoA>PWM_MAX)*motoA=PWM_MAX;
	if(*motoA<PWM_MIN)*motoA=PWM_MIN;
	

	if(*motoB>PWM_MAX)*motoB=PWM_MAX;
	if(*motoB<PWM_MIN)*motoB=PWM_MIN;

}
```

3）绝对值函数（非常通用，建议保存!!）
 入口参数：常规变量

- 通过与0比较，大于0则返回不变的值，小于0则返回相反的值。

```cpp
int abs(int p)
{
	int q;
	q=p>0?p:(-p);
	return q;
}
```

4）赋值函数
 入口参数：电机A脉冲个数，电机B脉冲个数

入口参数即为PID运算完成后的最终PWM值（后续会讲解PID算法的实现）

```
void Load(int moto1,int moto2)
{
	//1.研究正负号，对应正反转
	if(moto1>0)	
    	Ain1=1,Ain2=0;//正转
	else 				
    	Ain1=0,Ain2=1;//反转
	//2.研究PWM值
	TIM_SetCompare1(TIM1,abs(moto1));
	

  	//1.研究正负号，对应正反转
  	if(moto2>0)
  		Bin1=1,Bin2=0;
  	else 				
  		Bin1=0,Bin2=1;	
  	//2.研究PWM值
  	TIM_SetCompare4(TIM1,abs(moto2));

}
```

[【平衡小车制作】（二）电机驱动（超详解）_平衡小车pwm-CSDN博客](https://blog.csdn.net/weixin_44270218/article/details/113276624?spm=1001.2014.3001.5502)

直接看博客即可。

在MPU6050 中有个INT 引脚，每当MPU6050 有数据输出时，引脚INT 有相应的电平变化。可以将其触
发外部中断作为控制周期。当MPU6050 的读取一次数据，就控制一次，可以很好地保持MPU6050 数据的
实时性。如果我们将MPU6050 的采样频率设置为100HZ，即10ms 更新一次数据，那么平衡车的控制周期
就是10ms。推荐使用这种方式，而不是定时器方式

其他：**板子上有X ,Y的丝印**。把陀螺仪想象成一个飞机，**X轴所指即为机身方向，Y轴所指为机翼方向**（垂直于机身的方向），以确定俯仰角/翻滚角/偏航角。

<img src="https://img2023.cnblogs.com/blog/1536332/202310/1536332-20231020154449018-1040686802.png" alt="img" style="zoom:80%;" />

横向的是x轴，纵向的是Y轴，垂直与芯片的是Z轴。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8c1a683dd4744177b067db0ee991a5a5.png)



### 7、PID控制算法

一、PID控制算法
  PID控制，即为对偏差进行比例、积分和微分控制。由三个元素构成，分别是比例（P），积分（I），微分（D）。
  工程中P必然存在，在P的基础上又有如PI控制（比例积分），PD控制（比例微分），PID控制（比例积分微分）。

比例项：提高响应速度，减小静差。
积分项：消除稳态误差。
微分项：减小震荡以及超调。
二、位置式PID
1.理论分析
  位置式PID是根据编码器的脉冲累加测量电机的位置信息，并与目标值进行比较，得到控制偏差，然后通过对偏差的比例、积分、微信进行控制，使偏差趋向于零的过程。
2.公式
$$
PWM_out=Kp×e(k)+Ki×Σe(k)+Kd×[e(k)-e(k-1)]
$$

- e(k)：本次偏差
- e(k-1)：上一次偏差
- Σe(k)：e(k)以及以前的偏差的累积和，其中k为1,2,…
- PWM_out：输出

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210204211959300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3MDIxOA==,size_16,color_FFFFFF,t_70#pic_center)

```
int Position_PID(int Encoder, int Target)
{
	static float Bias, PWM_out, Integral_bias, Last_bias;
	Bias = Encoder-Target;		// 计算偏差
	Integral_bias += Bias;		// 计算偏差的积分
	// 位置式PID控制器公式
	PWM_out = Position_Kp*Bias+Position_Ki* Integral_bias+ Position_KD*(Bias- Last_bias)
	Last_bias = Bias;			// 保存上一次偏差
	return PWM_out;				// 输出
}
```

#### 三、直立环

1.理论

  小车往那边倒，车轮就往哪边开，这样就可以保持车子的平衡。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210204212234967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3MDIxOA==,size_16,color_FFFFFF,t_70#pic_center)

2.公式
$$
a=b1×θ+b2×θ’;
$$
比例微分控制
$$
PDout=Kp×Angle+Kd×(Angle- Angle_last)
$$
3.结构框图

<img src="https://img-blog.csdnimg.cn/20210204212505582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3MDIxOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:80%;" />

4.比较

① 纯比例控制：
 只存在大小与角度偏差成正比的回复力
 a=b1×θ;
（纯比例控制【Pout=Kp×Angle】）
② 比例微分控制：
 大小与角度成正比，方向与角速度成正比的回复力；
 大小与角速度成正比，方向与回复力成反比的阻尼力。
$$
a=b1×θ+b2×θ’;
$$
比例微分控制
$$
PDout=Kp×Angle+Kd×(Angle- Angle_last)
$$

#### 四、速度环、串级PID

1.理论

  通过速度反馈使得小车保持平衡。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210204212848390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3MDIxOA==,size_16,color_FFFFFF,t_70#pic_center)

图4 速度环

2.串级控制系统

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210204213022544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3MDIxOA==,size_16,color_FFFFFF,t_70#pic_center)

图5 速度环、串级PID

- **速度环输入**：① 给定速度；② 速度反馈。
- **速度环输出**：角度值（直立环的期望角度输入）
- **直立环输入**：① 给定角度（速度环输出）；② 角度反馈。
- **直立环输出**：PWM（直接控制小车

3.公式

① 【PD控制器】直立环输出=Kp1×角度偏差+Kd×角度偏差微分
（角度偏差=真实角度-期望角度）

② 【PI控制器】速度环输出=Kp2×编码器偏差+Ki×编码器偏差的积分
（编码器偏差=反馈编码器值-期望编码器值）
【Notes：（1）速度环输出=直立环的期望角度;（2）Kp1：直立环Kp;（3）Kp2：速度环Kp】

③ 串级输出out=Kp1×真实角度+Kd×角度偏差的微分-Kp1×(Kp2×编码器偏差-Ki×编码器偏差的积分)



一、直立环（PD控制器）
1.中文公式
 直立环输出=Kp1×角度偏差+Kd×角度偏差的微分
 // 角度偏差=真实角度-期望角度

2.英文公式
 直立环PD控制器：
$$
Kp×Ek+Kd×Ek_D
$$
 （Ek：角度偏差；Ek_D：角度偏差的微分）

Ek=真实角度-期望角度（Angle-Med，由陀螺仪MPU6050测得）
Ek_D=真实角速度（gyro_Y，由陀螺仪MPU6050测得）
3.软件编程
  根据理论公式进行软件编程，相信看完上面的讲解后这段代码应该比较清晰易懂。

```
/*****************  
直立环PD控制器：Kp*Ek+Kd*Ek_D
入口：Med:机械中值(期望角度)，Angle:真实角度，gyro_Y:真实角速度
出口：直立环输出
******************/
int Vertical(float Med,float Angle,float gyro_Y) 
{
  int PWM_out;
  
  PWM_out = Vertical_Kp*(Angle-Med)+Vertical_Kd*(gyro_Y-0);
  
  return PWM_out;
} 

```

二、速度环（PI控制器）
1.中文公式

 速度环输出=Kp2×电机速度偏差+Ki2×电机速度偏差的积分
 // 电机速度偏差=真实速度-期望速度

2.英文公式

 速度环PI控制器：
$$
Kp×Ek+Ki×Ek_S
$$
 （Ek：电机速度偏差；Ek_S：电机速度偏差的积分）

Ek=真实速度-期望速度（真实速度：左电机速度+右电机速度；期望速度：0）
Ek_S=速度偏差的累加
3.低通滤波

  期间需要低频滤波，我们是以直立环为主，速度环为辅，速度环相对于直立环来说是一个干扰，最终目的是直立。低频滤波作用是使得波形更加平滑，滤除高频干扰，防止速度过大影响直立环正常工作。

4.积分限幅

  通过比较限制积分在规定范围内变动，不得超出。

5.软件编程

  根据理论公式进行软件编程，相信看完上面的讲解后这段代码应该比较清晰易懂。


```
/*****************  
速度环PI控制器：Kp*Ek+Ki*Ek_S(Ek_S：偏差的积分)
******************/
int Velocity(int Target,int encoder_left,int encoder_right)
{
  // 定义成静态变量，保存在静态存储器，使得变量不丢掉
  static int PWM_out,Encoder_Err,Encoder_S,EnC_Err_Lowout,EnC_Err_Lowout_last;
  float a=0.7;
  
  // 1.计算速度偏差
  //舍去误差--我的理解：能够让速度为"0"的角度，就是机械中值。
  Encoder_Err = ((encoder_left+encoder_right)-Target);
  
  // 2.对速度偏差进行低通滤波
  // low_out = (1-a)*Ek+a*low_out_last
  EnC_Err_Lowout = (1-a)*Encoder_Err + a*EnC_Err_Lowout_last; // 使得波形更加平滑，滤除高频干扰，放置速度突变
  EnC_Err_Lowout_last = EnC_Err_Lowout;   // 防止速度过大影响直立环的正常工作
  
  // 3.对速度偏差积分出位移
  Encoder_S+=EnC_Err_Lowout;
  
  // 4.积分限幅
  Encoder_S=Encoder_S>10000?10000:(Encoder_S<(-10000)?(-10000):Encoder_S);
  
  // 5.速度环控制输出
  PWM_out = Velocity_Kp*EnC_Err_Lowout+Velocity_Ki*Encoder_S;
  
  return PWM_out;
}

```

三、转向环
1.中文公式

 转向环输出=系数×Z轴角速度
 (Z轴角速度由陀螺仪MPU6050测得)

2.软件编程

  转向环的编程比较简单，我们只需设置一个参数调节Z轴角速度即可。

```
/*****************  
转向环：系数*Z轴角速度
******************/
int Turn(int gyro_Z)
{
  int PWM_out;

  PWM_out = (-0.6)*gyro_Z;

  return PWM_out;
}
```

四、控制函数
1、采集编码器数据和MPU6050角度信息

 编码器数据：左电机速度，右电机速度
（两个电机是相对安装，刚好相差180度，为了编码器输出极性一致，就需要对其中一个取反）
 MPU6050数据：角度数据，角速度数据，角加速度数据
2、将数据压入闭环控制中，计算出控制输出量

 直立环输出
 速度环输出
 转向环输出
3、把控制输出量加载到电机上，完成最终的控制

 左电机输出（编码器放置相对）
 右电机输出
 限幅
 赋值
4、控制中断函数
 首先要判断是否接受到中断请求，即检测MPU6050的ANT引脚是否处在低电平（即为发生中断），然后清除中断标志位，进行接下来三步（即上面的三个步骤）。

```
void EXTI9_5_IRQHandler(void)
{
  int PWM_out;
  if(EXTI_GetITStatus(EXTI_Line5)!=0) // 一级判定
  {
    if(PBin(5)==0)    // 二级判断
    { 
      EXTI_ClearITPendingBit(EXTI_Line5); // 清除中断标志位
      // 1.采集编码器数据&MPU6050角度信息
      // 电机是相对安装，刚好相差180度，为了编码器输出极性一致，就需要对其中一个取反
      Encoder_Left  = -Read_Speed(2); 
      Encoder_Right = Read_Speed(4);
      

      mpu_dmp_get_data(&Pitch,&Roll,&Yaw);	    // 读取角度
      MPU_Get_Gyroscope(&gyrox,&gyroy,&gyroz);  // 读取角速度
      MPU_Get_Accelerometer(&aacx,&aacy,&aacz); // 读取加速度
      // 2.将数据压入闭环控制中，计算出控制输出量
    		Velocity_out=Velocity(Target_Speed,Encoder_Left,Encoder_Right); // 速度环
      Vertical_out=Vertical(Velocity_out+Med_Angle,Roll,gyrox);			  // 直立环
    		Turn_out=Turn(gyroz);	
      
      PWM_out=Vertical_out;//最终输出
      
      // 3.把控制输出量加载到电机上，完成最终控制
      MOTO1 = PWM_out-Turn_out; // 左电机
      MOTO2 = PWM_out+Turn_out; // 右电机
      Limit(&MOTO1,&MOTO2);     // PWM限幅
      Load(MOTO1,MOTO2);        // 加载到电机上
    }

  }
}
```


五、整个控制函数源代码
1、control.c

```
#include "control.h"

float Med_Angle=0;      // 机械中值，能使得小车真正平衡住的角度 
float Target_Speed=0;	  // 期望速度。---二次开发接口，用于控制小车前进后退及其速度。
float 
  Vertical_Kp=0,
  Vertical_Kd=0;     // 直立环Kp、Kd
float 
  Velocity_Kp=0,     // 速度环Kp、Ki（正反馈）
  Velocity_Ki=0;
float 
  Turn_Kp=0;

int Vertical_out,Velocity_out,Turn_out; // 直立环&速度环&转向环的输出变量

int Vertical(float Med,float Angle,float gyro_Y); // 函数声明
int Velocity(int Target,int encoder_left,int encoder_right);
int Turn(int gyro_Z);

void EXTI9_5_IRQHandler(void)
{
  int PWM_out;
  if(EXTI_GetITStatus(EXTI_Line5)!=0) // 一级判定
  {
    if(PBin(5)==0)    // 二级判断
    { 
      EXTI_ClearITPendingBit(EXTI_Line5); // 清除中断标志位
      // 1.采集编码器数据&MPU6050角度信息
      // 电机是相对安装，刚好相差180度，为了编码器输出极性一致，就需要对其中一个取反
      Encoder_Left  = -Read_Speed(2); 
      Encoder_Right = Read_Speed(4);
      

      mpu_dmp_get_data(&Pitch,&Roll,&Yaw);	    // 读取角度
      MPU_Get_Gyroscope(&gyrox,&gyroy,&gyroz);  // 读取角速度
      MPU_Get_Accelerometer(&aacx,&aacy,&aacz); // 读取加速度
      // 2.将数据压入闭环控制中，计算出控制输出量
    		Velocity_out=Velocity(Target_Speed,Encoder_Left,Encoder_Right); // 速度环
      Vertical_out=Vertical(Velocity_out+Med_Angle,Roll,gyrox);			  // 直立环
    		Turn_out=Turn(gyroz);	
      
      PWM_out=Vertical_out;//最终输出
      
      // 3.把控制输出量加载到电机上，完成最终控制
      MOTO1 = PWM_out-Turn_out; // 左电机
      MOTO2 = PWM_out+Turn_out; // 右电机
      Limit(&MOTO1,&MOTO2);     // PWM限幅
      Load(MOTO1,MOTO2);        // 加载到电机上
    }

  }
}

/*****************  
直立环PD控制器：Kp*Ek+Kd*Ek_D

入口：Med:机械中值(期望角度)，Angle:真实角度，gyro_Y:真实角速度
出口：直立环输出
******************/
int Vertical(float Med,float Angle,float gyro_Y) 
{
  int PWM_out;

  PWM_out = Vertical_Kp*(Angle-Med)+Vertical_Kd*(gyro_Y-0);

  return PWM_out;
} 

/*****************  
速度环PI控制器：Kp*Ek+Ki*Ek_S(Ek_S：偏差的积分)
******************/
int Velocity(int Target,int encoder_left,int encoder_right)
{
  // 定义成静态变量，保存在静态存储器，使得变量不丢掉
  static int PWM_out,Encoder_Err,Encoder_S,EnC_Err_Lowout,EnC_Err_Lowout_last;
  float a=0.7;

  // 1.计算速度偏差
  //舍去误差--我的理解：能够让速度为"0"的角度，就是机械中值。
  Encoder_Err = ((encoder_left+encoder_right)-Target);
  // 2.对速度偏差进行低通滤波
  // low_out = (1-a)*Ek+a*low_out_last
  EnC_Err_Lowout = (1-a)*Encoder_Err + a*EnC_Err_Lowout_last; // 使得波形更加平滑，滤除高频干扰，放置速度突变
  EnC_Err_Lowout_last = EnC_Err_Lowout;   // 防止速度过大影响直立环的正常工作
  // 3.对速度偏差积分出位移
  Encoder_S+=EnC_Err_Lowout;
  // 4.积分限幅
  Encoder_S=Encoder_S>10000?10000:(Encoder_S<(-10000)?(-10000):Encoder_S);

  // 5.速度环控制输出
  PWM_out = Velocity_Kp*EnC_Err_Lowout+Velocity_Ki*Encoder_S;

  return PWM_out;
}

/*****************  
转向环：系数*Z轴角速度
******************/
int Turn(int gyro_Z)
{
  int PWM_out;

  PWM_out = Turn_Kp*gyro_Z;

  return PWM_out;
}
```

合并推导：

直立环输出
$$
Vertical_out=Kp1*(θ_r-θ_e)+Kd* (θ_r-θ_e)'
$$
速度环输出
$$
Velocity_out=Kp2*(E_r- E_e)+Ki*Σ(E_r- E_e)
$$
因为：
$$
θ_e	=	Velocity_out
$$
所以直立环输出Vertical_out =

= Kp1*{ θ_r-[ Kp2*(E_r- E_e)+Ki*Σ(E_r- E_e) ]}+Kd*(θ_r-θ_e)＇

= Kp1* θ_r- Kp1* Kp2*(E_r- E_e)- Kp1*Ki *Σ(E_r- E_e) +Kd*(θ_r-θ_e)＇

=
$$
Kp1* θ_r+ Kd*(θ_r-θ_e)＇-	Kp1* [Kp2*(E_r- E_e)+ Ki *Σ(E_r- E_e)]
$$
【中文】

=Kp1*真实角度+ Kd*角度偏差的微分***\*-\****Kp1* [Kp2*编码器偏差- Ki *编码器偏差的积分]

即：

串级输出OUT=
$$
Kp1* real_Angle +Kd* D( real_Angle- expect_Angle)-
Kp1*[Kp2*(Encoder_ real- Encoder_ expect)+Ki* S(Encoder_ real- Encoder_ expect)]
$$

### 8、四轴飞行器

MiniFly外形:

         HEAD
      M4  ↑  M1
       \     /
    	\   /
    	 \ /
    	 / \
    	/   \
       /     \
      M3     M2

硬件资源:
	1,MCU:STM32F411CEU6 (FLAH:512K, RAM:128K, 系统运行时钟频率:96MHz)
	2,9轴MPU9250连接在IIC1上(IMU_SCL:PB8, IMU_SDA:PB9, 通信方式:模拟IIC) 
	3,气压计BMP280连接在MPU9250的辅助IIC上(AUX_DA,AUX_CL)
	4,无线通信NFR51822连接在UART2上(NRF_RX:PA2, NRF_TX:PA3, NRF_FLOW_CTRL:PA0) 
	5,MOTOR1连接在TIM4_CH2上(PB7)
	6,MOTOR2连接在TIM4_CH1上(PB6)
	7,MOTOR3连接在TIM2_CH3上(PB10)
	8,MOTOR4连接在TIM2_CH1上(PA5)
	9,LED_BLUE_L连接在PB12上	(MORTOR3对应的蓝色LED, 高电平有效)
	10,LED_GREEN_L连接在PA6上	(MORTOR4对应的绿色LED, 低电平有效)
	11,LED_RED_L连接在PA7上		(MORTOR4对应的红色LED, 低电平有效)
	12,LED_GREEN_R连接在PC13上	(MORTOR1对应的绿色LED, 低电平有效)
	13,LED_RED_R连接在PC14上	(MORTOR1对应的红色LED, 低电平有效)
	14,扩展IIC接口(SDA:PB4, SCL:PB5) 
	15,扩展SPI2接口(SCK:PB13, MISO:PB14, MOSI:PB15)  
	16,扩展UART1接口(RX1:PB3, TX1:PA15, 外挂摄像头模块需用此接口)  
	17,扩展GPIO(CS0:PC15, CS1:PB0, CS2:PB1, CS3:PA8). 	
	18,USB_SLAVE接口(USB_ID:PA10, USB_DM:PA11, USB_DP:PA12)

实验现象:
	MiniFly开机后，MOTOR1~4电机以20%的占空比依次转动50ms,然后关闭电机; 

##### 8.1 mian.c

```
#include "system.h"	/*头文件集合*/

TaskHandle_t startTaskHandle;
static void startTask(void *arg);

int main() 
{
	systemInit();			/*底层硬件初始化*/	

	xTaskCreate(startTask, "START_TASK", 300, NULL, 2, &startTaskHandle);	/*创建起始任务*/

	vTaskStartScheduler();	/*开启任务调度*/

	while(1){};
}
/*创建任务*/
void startTask(void *arg)
{
	taskENTER_CRITICAL();	/*进入临界区*/
	
	xTaskCreate(radiolinkTask, "RADIOLINK", 150, NULL, 5, NULL);/*创建无线连接任务*/
	
	xTaskCreate(usblinkRxTask, "USBLINK_RX", 150, NULL, 4, NULL);	/*创建usb接收任务*/
	xTaskCreate(usblinkTxTask, "USBLINK_TX", 150, NULL, 3, NULL);	/*创建usb发送任务*/
	
	xTaskCreate(atkpTxTask, "ATKP_TX", 150, NULL, 3, NULL);			/*创建atkp发送任务任务*/
	xTaskCreate(atkpRxAnlTask, "ATKP_RX_ANL", 300, NULL, 6, NULL);	/*创建atkp解析任务*/
	
	xTaskCreate(configParamTask, "CONFIG_TASK", 150, NULL, 1, NULL);	/*创建参数配置任务*/
	
	xTaskCreate(pmTask, "PWRMGNT", 150, NULL, 2, NULL);					/*创建电源管理任务*/
		
	xTaskCreate(stabilizerTask, "STABILIZER", 450, NULL, 5, NULL);		/*创建姿态任务*/
	
	xTaskCreate(wifiLinkTask, "WIFILINK", 150, NULL, 4, NULL);			/*创建通信连接任务*/
	
	printf("Free heap: %d bytes\n", xPortGetFreeHeapSize());			/*打印剩余堆栈大小*/
	
	vTaskDelete(startTaskHandle);										/*删除开始任务*/
		
	taskEXIT_CRITICAL();	/*退出临界区*/
} 

void vApplicationIdleHook( void )
{
	static u32 tickWatchdogReset = 0;

	portTickType tickCount = getSysTickCnt();

	if (tickCount - tickWatchdogReset > WATCHDOG_RESET_MS)
	{
		tickWatchdogReset = tickCount;
		watchdogReset();
	}
	
	__WFI();	/*进入低功耗模式*/
}

```

系统初始化和创建任务

首先在main函数里创建任务，开启任务调度

```
xTaskCreate(startTask, "START_TASK", 300, NULL, 2, &startTaskHandle);	/*创建起始任务*/
```

然后在startTask中创建要执行的各个任务

```
/*创建任务*/
void startTask(void *arg)
{
	taskENTER_CRITICAL();	/*进入临界区*/
	
	xTaskCreate(radiolinkTask, "RADIOLINK", 150, NULL, 5, NULL);/*创建无线连接任务*/
	
	xTaskCreate(usblinkRxTask, "USBLINK_RX", 150, NULL, 4, NULL);	/*创建usb接收任务*/
	xTaskCreate(usblinkTxTask, "USBLINK_TX", 150, NULL, 3, NULL);	/*创建usb发送任务*/
	
	xTaskCreate(atkpTxTask, "ATKP_TX", 150, NULL, 3, NULL);			/*创建atkp发送任务任务*/
	xTaskCreate(atkpRxAnlTask, "ATKP_RX_ANL", 300, NULL, 6, NULL);	/*创建atkp解析任务*/
	
	xTaskCreate(configParamTask, "CONFIG_TASK", 150, NULL, 1, NULL);	/*创建参数配置任务*/
	
	xTaskCreate(pmTask, "PWRMGNT", 150, NULL, 2, NULL);					/*创建电源管理任务*/
		
	xTaskCreate(stabilizerTask, "STABILIZER", 450, NULL, 5, NULL);		/*创建姿态任务*/
	
	xTaskCreate(wifiLinkTask, "WIFILINK", 150, NULL, 4, NULL);			/*创建通信连接任务*/
	
	printf("Free heap: %d bytes\n", xPortGetFreeHeapSize());			/*打印剩余堆栈大小*/
	
	vTaskDelete(startTaskHandle);										/*删除开始任务*/
		
	taskEXIT_CRITICAL();	/*退出临界区*/
} 
```

先进入临界区，然后创建任务，然后删除开始任务，退出临界区

```
void vApplicationIdleHook( void )
{
	static u32 tickWatchdogReset = 0;

	portTickType tickCount = getSysTickCnt();

	if (tickCount - tickWatchdogReset > WATCHDOG_RESET_MS)
	{
		tickWatchdogReset = tickCount;
		watchdogReset();
	}
	
	__WFI();	/*进入低功耗模式*/
}
```

实现FreeRTOS的空闲任务钩子（idle hook）的函数，用于在系统空闲时执行特定操作。这个函数的主要功能是监控系统空闲时间，并在超过设定的时间阈值时重置看门狗计时器，并使设备进入低功耗模式。下面是对每一部分的详细说明：

1. **变量定义和初始化**:
   - `static u32 tickWatchdogReset = 0;`：定义一个静态变量来记录上一次看门狗被重置的时刻。静态变量保证了变量的值在函数调用之间保持不变。
2. **获取当前系统时钟**:
   - `portTickType tickCount = getSysTickCnt();`：调用`getSysTickCnt()`函数获取当前的系统时钟计数（假设这个函数返回自系统启动以来的滴答计数）。
3. **检查是否需要重置看门狗**:
   - `if (tickCount - tickWatchdogReset > WATCHDOG_RESET_MS)`：此条件检查自上次看门狗重置以来是否已经过去了超过`WATCHDOG_RESET_MS`毫秒，设置看门狗复位时间为100ms。
   - `tickWatchdogReset = tickCount;`：如果是，更新`tickWatchdogReset`变量为当前时钟计数，标记新的重置时间点。
   - `watchdogReset();`：调用`watchdogReset()`函数来重置看门狗计时器，防止系统由于看门狗超时而重启。
4. **进入低功耗模式**:
   - `__WFI();`：调用`__WFI()`（Wait For Interrupt）指令使MCU进入低功耗模式直到下一个中断发生。

这种实现方式对于在系统空闲时减少能耗和确保系统安全运行非常有效。确保您的系统中`getSysTickCnt()`和`watchdogReset()`函数正确实现，且`WATCHDOG_RESET_MS`宏定义了一个合适的值来满足您的看门狗超时要求。
